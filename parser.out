Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    NOT

Grammar

Rule 0     S' -> program
Rule 1     program -> functionlist block
Rule 2     functionlist -> function functionlist
Rule 3     functionlist -> empty
Rule 4     function -> FUNCTION ID ( argument ) { block RETURN boolean }
Rule 5     function -> FUNCTION ID ( argument ) { block RETURN }
Rule 6     argument -> ID , argument
Rule 7     argument -> ID
Rule 8     argument -> empty
Rule 9     empty -> <empty>
Rule 10    block -> statement block
Rule 11    block -> statement
Rule 12    statement -> declaration
Rule 13    statement -> initialization
Rule 14    statement -> assign
Rule 15    statement -> funcall
Rule 16    statement -> unary
Rule 17    statement -> while
Rule 18    statement -> for
Rule 19    statement -> if
Rule 20    statement -> print
Rule 21    declaration -> VARIABLE ID
Rule 22    initialization -> VARIABLE ID = boolean
Rule 23    assign -> ID = boolean
Rule 24    unary -> increment
Rule 25    unary -> decrement
Rule 26    increment -> ID INCRMNT
Rule 27    decrement -> ID DECRMNT
Rule 28    funcall -> ID ( paramlist )
Rule 29    paramlist -> boolean , paramlist
Rule 30    paramlist -> boolean
Rule 31    paramlist -> empty
Rule 32    if -> IF boolean { block } elif
Rule 33    elif -> ELSEIF boolean { block } elif
Rule 34    elif -> ELSE { block }
Rule 35    elif -> empty
Rule 36    while -> WHILE boolean { block }
Rule 37    for -> FOR ( initialization , boolean , assign ) { block }
Rule 38    for -> FOR ( initialization , boolean , unary ) { block }
Rule 39    for -> FOR ID IN RANGE ( expression , expression ) { block }
Rule 40    print -> PRINT ( plist )
Rule 41    plist -> pstat , plist
Rule 42    plist -> pstat
Rule 43    pstat -> boolean
Rule 44    boolean -> boolean OR boolterm
Rule 45    boolean -> boolterm
Rule 46    boolterm -> boolterm AND boolterm1
Rule 47    boolterm -> boolterm1
Rule 48    boolterm1 -> ! boolterm2
Rule 49    boolterm1 -> boolterm2
Rule 50    boolterm2 -> condition
Rule 51    boolterm2 -> expression
Rule 52    boolterm2 -> FALSE
Rule 53    boolterm2 -> TRUE
Rule 54    condition -> expression > expression
Rule 55    condition -> expression < expression
Rule 56    condition -> expression GTEQL expression
Rule 57    condition -> expression LTEQL expression
Rule 58    condition -> expression NOTEQL expression
Rule 59    condition -> expression BOOLEQL expression
Rule 60    expression -> expression + term
Rule 61    expression -> expression - term
Rule 62    expression -> term
Rule 63    term -> term * factor
Rule 64    term -> term / factor
Rule 65    term -> factor
Rule 66    factor -> ID
Rule 67    factor -> NUMBER
Rule 68    factor -> STRING
Rule 69    factor -> ( expression )
Rule 70    factor -> ternary
Rule 71    ternary -> ( boolean ) ? ( boolean : boolean )
Rule 72    factor -> funcall

Terminals, with rules where they appear

!                    : 48
(                    : 4 5 28 37 38 39 40 69 71 71
)                    : 4 5 28 37 38 39 40 69 71 71
*                    : 63
+                    : 60
,                    : 6 29 37 37 38 38 39 41
-                    : 61
/                    : 64
:                    : 71
<                    : 55
=                    : 22 23
>                    : 54
?                    : 71
AND                  : 46
BOOLEQL              : 59
DECRMNT              : 27
ELSE                 : 34
ELSEIF               : 33
FALSE                : 52
FOR                  : 37 38 39
FUNCTION             : 4 5
GTEQL                : 56
ID                   : 4 5 6 7 21 22 23 26 27 28 39 66
IF                   : 32
IN                   : 39
INCRMNT              : 26
LTEQL                : 57
NOT                  : 
NOTEQL               : 58
NUMBER               : 67
OR                   : 44
PRINT                : 40
RANGE                : 39
RETURN               : 4 5
STRING               : 68
TRUE                 : 53
VARIABLE             : 21 22
WHILE                : 36
error                : 
{                    : 4 5 32 33 34 36 37 38 39
}                    : 4 5 32 33 34 36 37 38 39

Nonterminals, with rules where they appear

argument             : 4 5 6
assign               : 14 37
block                : 1 4 5 10 32 33 34 36 37 38 39
boolean              : 4 22 23 29 30 32 33 36 37 38 43 44 71 71 71
boolterm             : 44 45 46
boolterm1            : 46 47
boolterm2            : 48 49
condition            : 50
declaration          : 12
decrement            : 25
elif                 : 32 33
empty                : 3 8 31 35
expression           : 39 39 51 54 54 55 55 56 56 57 57 58 58 59 59 60 61 69
factor               : 63 64 65
for                  : 18
funcall              : 15 72
function             : 2
functionlist         : 1 2
if                   : 19
increment            : 24
initialization       : 13 37 38
paramlist            : 28 29
plist                : 40 41
print                : 20
program              : 0
pstat                : 41 42
statement            : 10 11
term                 : 60 61 62 63 64
ternary              : 70
unary                : 16 38
while                : 17

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . functionlist block
    (2) functionlist -> . function functionlist
    (3) functionlist -> . empty
    (4) function -> . FUNCTION ID ( argument ) { block RETURN boolean }
    (5) function -> . FUNCTION ID ( argument ) { block RETURN }
    (9) empty -> .

    FUNCTION        shift and go to state 5
    VARIABLE        reduce using rule 9 (empty -> .)
    ID              reduce using rule 9 (empty -> .)
    WHILE           reduce using rule 9 (empty -> .)
    FOR             reduce using rule 9 (empty -> .)
    IF              reduce using rule 9 (empty -> .)
    PRINT           reduce using rule 9 (empty -> .)

    program                        shift and go to state 1
    functionlist                   shift and go to state 2
    function                       shift and go to state 3
    empty                          shift and go to state 4

state 1

    (0) S' -> program .



state 2

    (1) program -> functionlist . block
    (10) block -> . statement block
    (11) block -> . statement
    (12) statement -> . declaration
    (13) statement -> . initialization
    (14) statement -> . assign
    (15) statement -> . funcall
    (16) statement -> . unary
    (17) statement -> . while
    (18) statement -> . for
    (19) statement -> . if
    (20) statement -> . print
    (21) declaration -> . VARIABLE ID
    (22) initialization -> . VARIABLE ID = boolean
    (23) assign -> . ID = boolean
    (28) funcall -> . ID ( paramlist )
    (24) unary -> . increment
    (25) unary -> . decrement
    (36) while -> . WHILE boolean { block }
    (37) for -> . FOR ( initialization , boolean , assign ) { block }
    (38) for -> . FOR ( initialization , boolean , unary ) { block }
    (39) for -> . FOR ID IN RANGE ( expression , expression ) { block }
    (32) if -> . IF boolean { block } elif
    (40) print -> . PRINT ( plist )
    (26) increment -> . ID INCRMNT
    (27) decrement -> . ID DECRMNT

    VARIABLE        shift and go to state 17
    ID              shift and go to state 18
    WHILE           shift and go to state 21
    FOR             shift and go to state 22
    IF              shift and go to state 23
    PRINT           shift and go to state 24

    block                          shift and go to state 6
    statement                      shift and go to state 7
    declaration                    shift and go to state 8
    initialization                 shift and go to state 9
    assign                         shift and go to state 10
    funcall                        shift and go to state 11
    unary                          shift and go to state 12
    while                          shift and go to state 13
    for                            shift and go to state 14
    if                             shift and go to state 15
    print                          shift and go to state 16
    increment                      shift and go to state 19
    decrement                      shift and go to state 20

state 3

    (2) functionlist -> function . functionlist
    (2) functionlist -> . function functionlist
    (3) functionlist -> . empty
    (4) function -> . FUNCTION ID ( argument ) { block RETURN boolean }
    (5) function -> . FUNCTION ID ( argument ) { block RETURN }
    (9) empty -> .

    FUNCTION        shift and go to state 5
    VARIABLE        reduce using rule 9 (empty -> .)
    ID              reduce using rule 9 (empty -> .)
    WHILE           reduce using rule 9 (empty -> .)
    FOR             reduce using rule 9 (empty -> .)
    IF              reduce using rule 9 (empty -> .)
    PRINT           reduce using rule 9 (empty -> .)

    function                       shift and go to state 3
    functionlist                   shift and go to state 25
    empty                          shift and go to state 4

state 4

    (3) functionlist -> empty .

    VARIABLE        reduce using rule 3 (functionlist -> empty .)
    ID              reduce using rule 3 (functionlist -> empty .)
    WHILE           reduce using rule 3 (functionlist -> empty .)
    FOR             reduce using rule 3 (functionlist -> empty .)
    IF              reduce using rule 3 (functionlist -> empty .)
    PRINT           reduce using rule 3 (functionlist -> empty .)


state 5

    (4) function -> FUNCTION . ID ( argument ) { block RETURN boolean }
    (5) function -> FUNCTION . ID ( argument ) { block RETURN }

    ID              shift and go to state 26


state 6

    (1) program -> functionlist block .

    $end            reduce using rule 1 (program -> functionlist block .)


state 7

    (10) block -> statement . block
    (11) block -> statement .
    (10) block -> . statement block
    (11) block -> . statement
    (12) statement -> . declaration
    (13) statement -> . initialization
    (14) statement -> . assign
    (15) statement -> . funcall
    (16) statement -> . unary
    (17) statement -> . while
    (18) statement -> . for
    (19) statement -> . if
    (20) statement -> . print
    (21) declaration -> . VARIABLE ID
    (22) initialization -> . VARIABLE ID = boolean
    (23) assign -> . ID = boolean
    (28) funcall -> . ID ( paramlist )
    (24) unary -> . increment
    (25) unary -> . decrement
    (36) while -> . WHILE boolean { block }
    (37) for -> . FOR ( initialization , boolean , assign ) { block }
    (38) for -> . FOR ( initialization , boolean , unary ) { block }
    (39) for -> . FOR ID IN RANGE ( expression , expression ) { block }
    (32) if -> . IF boolean { block } elif
    (40) print -> . PRINT ( plist )
    (26) increment -> . ID INCRMNT
    (27) decrement -> . ID DECRMNT

    $end            reduce using rule 11 (block -> statement .)
    }               reduce using rule 11 (block -> statement .)
    RETURN          reduce using rule 11 (block -> statement .)
    VARIABLE        shift and go to state 17
    ID              shift and go to state 18
    WHILE           shift and go to state 21
    FOR             shift and go to state 22
    IF              shift and go to state 23
    PRINT           shift and go to state 24

    statement                      shift and go to state 7
    block                          shift and go to state 27
    declaration                    shift and go to state 8
    initialization                 shift and go to state 9
    assign                         shift and go to state 10
    funcall                        shift and go to state 11
    unary                          shift and go to state 12
    while                          shift and go to state 13
    for                            shift and go to state 14
    if                             shift and go to state 15
    print                          shift and go to state 16
    increment                      shift and go to state 19
    decrement                      shift and go to state 20

state 8

    (12) statement -> declaration .

    VARIABLE        reduce using rule 12 (statement -> declaration .)
    ID              reduce using rule 12 (statement -> declaration .)
    WHILE           reduce using rule 12 (statement -> declaration .)
    FOR             reduce using rule 12 (statement -> declaration .)
    IF              reduce using rule 12 (statement -> declaration .)
    PRINT           reduce using rule 12 (statement -> declaration .)
    $end            reduce using rule 12 (statement -> declaration .)
    }               reduce using rule 12 (statement -> declaration .)
    RETURN          reduce using rule 12 (statement -> declaration .)


state 9

    (13) statement -> initialization .

    VARIABLE        reduce using rule 13 (statement -> initialization .)
    ID              reduce using rule 13 (statement -> initialization .)
    WHILE           reduce using rule 13 (statement -> initialization .)
    FOR             reduce using rule 13 (statement -> initialization .)
    IF              reduce using rule 13 (statement -> initialization .)
    PRINT           reduce using rule 13 (statement -> initialization .)
    $end            reduce using rule 13 (statement -> initialization .)
    }               reduce using rule 13 (statement -> initialization .)
    RETURN          reduce using rule 13 (statement -> initialization .)


state 10

    (14) statement -> assign .

    VARIABLE        reduce using rule 14 (statement -> assign .)
    ID              reduce using rule 14 (statement -> assign .)
    WHILE           reduce using rule 14 (statement -> assign .)
    FOR             reduce using rule 14 (statement -> assign .)
    IF              reduce using rule 14 (statement -> assign .)
    PRINT           reduce using rule 14 (statement -> assign .)
    $end            reduce using rule 14 (statement -> assign .)
    }               reduce using rule 14 (statement -> assign .)
    RETURN          reduce using rule 14 (statement -> assign .)


state 11

    (15) statement -> funcall .

    VARIABLE        reduce using rule 15 (statement -> funcall .)
    ID              reduce using rule 15 (statement -> funcall .)
    WHILE           reduce using rule 15 (statement -> funcall .)
    FOR             reduce using rule 15 (statement -> funcall .)
    IF              reduce using rule 15 (statement -> funcall .)
    PRINT           reduce using rule 15 (statement -> funcall .)
    $end            reduce using rule 15 (statement -> funcall .)
    }               reduce using rule 15 (statement -> funcall .)
    RETURN          reduce using rule 15 (statement -> funcall .)


state 12

    (16) statement -> unary .

    VARIABLE        reduce using rule 16 (statement -> unary .)
    ID              reduce using rule 16 (statement -> unary .)
    WHILE           reduce using rule 16 (statement -> unary .)
    FOR             reduce using rule 16 (statement -> unary .)
    IF              reduce using rule 16 (statement -> unary .)
    PRINT           reduce using rule 16 (statement -> unary .)
    $end            reduce using rule 16 (statement -> unary .)
    }               reduce using rule 16 (statement -> unary .)
    RETURN          reduce using rule 16 (statement -> unary .)


state 13

    (17) statement -> while .

    VARIABLE        reduce using rule 17 (statement -> while .)
    ID              reduce using rule 17 (statement -> while .)
    WHILE           reduce using rule 17 (statement -> while .)
    FOR             reduce using rule 17 (statement -> while .)
    IF              reduce using rule 17 (statement -> while .)
    PRINT           reduce using rule 17 (statement -> while .)
    $end            reduce using rule 17 (statement -> while .)
    }               reduce using rule 17 (statement -> while .)
    RETURN          reduce using rule 17 (statement -> while .)


state 14

    (18) statement -> for .

    VARIABLE        reduce using rule 18 (statement -> for .)
    ID              reduce using rule 18 (statement -> for .)
    WHILE           reduce using rule 18 (statement -> for .)
    FOR             reduce using rule 18 (statement -> for .)
    IF              reduce using rule 18 (statement -> for .)
    PRINT           reduce using rule 18 (statement -> for .)
    $end            reduce using rule 18 (statement -> for .)
    }               reduce using rule 18 (statement -> for .)
    RETURN          reduce using rule 18 (statement -> for .)


state 15

    (19) statement -> if .

    VARIABLE        reduce using rule 19 (statement -> if .)
    ID              reduce using rule 19 (statement -> if .)
    WHILE           reduce using rule 19 (statement -> if .)
    FOR             reduce using rule 19 (statement -> if .)
    IF              reduce using rule 19 (statement -> if .)
    PRINT           reduce using rule 19 (statement -> if .)
    $end            reduce using rule 19 (statement -> if .)
    }               reduce using rule 19 (statement -> if .)
    RETURN          reduce using rule 19 (statement -> if .)


state 16

    (20) statement -> print .

    VARIABLE        reduce using rule 20 (statement -> print .)
    ID              reduce using rule 20 (statement -> print .)
    WHILE           reduce using rule 20 (statement -> print .)
    FOR             reduce using rule 20 (statement -> print .)
    IF              reduce using rule 20 (statement -> print .)
    PRINT           reduce using rule 20 (statement -> print .)
    $end            reduce using rule 20 (statement -> print .)
    }               reduce using rule 20 (statement -> print .)
    RETURN          reduce using rule 20 (statement -> print .)


state 17

    (21) declaration -> VARIABLE . ID
    (22) initialization -> VARIABLE . ID = boolean

    ID              shift and go to state 28


state 18

    (23) assign -> ID . = boolean
    (28) funcall -> ID . ( paramlist )
    (26) increment -> ID . INCRMNT
    (27) decrement -> ID . DECRMNT

    =               shift and go to state 29
    (               shift and go to state 30
    INCRMNT         shift and go to state 31
    DECRMNT         shift and go to state 32


state 19

    (24) unary -> increment .

    VARIABLE        reduce using rule 24 (unary -> increment .)
    ID              reduce using rule 24 (unary -> increment .)
    WHILE           reduce using rule 24 (unary -> increment .)
    FOR             reduce using rule 24 (unary -> increment .)
    IF              reduce using rule 24 (unary -> increment .)
    PRINT           reduce using rule 24 (unary -> increment .)
    $end            reduce using rule 24 (unary -> increment .)
    }               reduce using rule 24 (unary -> increment .)
    RETURN          reduce using rule 24 (unary -> increment .)
    )               reduce using rule 24 (unary -> increment .)


state 20

    (25) unary -> decrement .

    VARIABLE        reduce using rule 25 (unary -> decrement .)
    ID              reduce using rule 25 (unary -> decrement .)
    WHILE           reduce using rule 25 (unary -> decrement .)
    FOR             reduce using rule 25 (unary -> decrement .)
    IF              reduce using rule 25 (unary -> decrement .)
    PRINT           reduce using rule 25 (unary -> decrement .)
    $end            reduce using rule 25 (unary -> decrement .)
    }               reduce using rule 25 (unary -> decrement .)
    RETURN          reduce using rule 25 (unary -> decrement .)
    )               reduce using rule 25 (unary -> decrement .)


state 21

    (36) while -> WHILE . boolean { block }
    (44) boolean -> . boolean OR boolterm
    (45) boolean -> . boolterm
    (46) boolterm -> . boolterm AND boolterm1
    (47) boolterm -> . boolterm1
    (48) boolterm1 -> . ! boolterm2
    (49) boolterm1 -> . boolterm2
    (50) boolterm2 -> . condition
    (51) boolterm2 -> . expression
    (52) boolterm2 -> . FALSE
    (53) boolterm2 -> . TRUE
    (54) condition -> . expression > expression
    (55) condition -> . expression < expression
    (56) condition -> . expression GTEQL expression
    (57) condition -> . expression LTEQL expression
    (58) condition -> . expression NOTEQL expression
    (59) condition -> . expression BOOLEQL expression
    (60) expression -> . expression + term
    (61) expression -> . expression - term
    (62) expression -> . term
    (63) term -> . term * factor
    (64) term -> . term / factor
    (65) term -> . factor
    (66) factor -> . ID
    (67) factor -> . NUMBER
    (68) factor -> . STRING
    (69) factor -> . ( expression )
    (70) factor -> . ternary
    (72) factor -> . funcall
    (71) ternary -> . ( boolean ) ? ( boolean : boolean )
    (28) funcall -> . ID ( paramlist )

    !               shift and go to state 36
    FALSE           shift and go to state 40
    TRUE            shift and go to state 41
    ID              shift and go to state 44
    NUMBER          shift and go to state 45
    STRING          shift and go to state 46
    (               shift and go to state 47

    boolean                        shift and go to state 33
    boolterm                       shift and go to state 34
    boolterm1                      shift and go to state 35
    boolterm2                      shift and go to state 37
    condition                      shift and go to state 38
    expression                     shift and go to state 39
    term                           shift and go to state 42
    factor                         shift and go to state 43
    ternary                        shift and go to state 48
    funcall                        shift and go to state 49

state 22

    (37) for -> FOR . ( initialization , boolean , assign ) { block }
    (38) for -> FOR . ( initialization , boolean , unary ) { block }
    (39) for -> FOR . ID IN RANGE ( expression , expression ) { block }

    (               shift and go to state 50
    ID              shift and go to state 51


state 23

    (32) if -> IF . boolean { block } elif
    (44) boolean -> . boolean OR boolterm
    (45) boolean -> . boolterm
    (46) boolterm -> . boolterm AND boolterm1
    (47) boolterm -> . boolterm1
    (48) boolterm1 -> . ! boolterm2
    (49) boolterm1 -> . boolterm2
    (50) boolterm2 -> . condition
    (51) boolterm2 -> . expression
    (52) boolterm2 -> . FALSE
    (53) boolterm2 -> . TRUE
    (54) condition -> . expression > expression
    (55) condition -> . expression < expression
    (56) condition -> . expression GTEQL expression
    (57) condition -> . expression LTEQL expression
    (58) condition -> . expression NOTEQL expression
    (59) condition -> . expression BOOLEQL expression
    (60) expression -> . expression + term
    (61) expression -> . expression - term
    (62) expression -> . term
    (63) term -> . term * factor
    (64) term -> . term / factor
    (65) term -> . factor
    (66) factor -> . ID
    (67) factor -> . NUMBER
    (68) factor -> . STRING
    (69) factor -> . ( expression )
    (70) factor -> . ternary
    (72) factor -> . funcall
    (71) ternary -> . ( boolean ) ? ( boolean : boolean )
    (28) funcall -> . ID ( paramlist )

    !               shift and go to state 36
    FALSE           shift and go to state 40
    TRUE            shift and go to state 41
    ID              shift and go to state 44
    NUMBER          shift and go to state 45
    STRING          shift and go to state 46
    (               shift and go to state 47

    boolean                        shift and go to state 52
    boolterm                       shift and go to state 34
    boolterm1                      shift and go to state 35
    boolterm2                      shift and go to state 37
    condition                      shift and go to state 38
    expression                     shift and go to state 39
    term                           shift and go to state 42
    factor                         shift and go to state 43
    ternary                        shift and go to state 48
    funcall                        shift and go to state 49

state 24

    (40) print -> PRINT . ( plist )

    (               shift and go to state 53


state 25

    (2) functionlist -> function functionlist .

    VARIABLE        reduce using rule 2 (functionlist -> function functionlist .)
    ID              reduce using rule 2 (functionlist -> function functionlist .)
    WHILE           reduce using rule 2 (functionlist -> function functionlist .)
    FOR             reduce using rule 2 (functionlist -> function functionlist .)
    IF              reduce using rule 2 (functionlist -> function functionlist .)
    PRINT           reduce using rule 2 (functionlist -> function functionlist .)


state 26

    (4) function -> FUNCTION ID . ( argument ) { block RETURN boolean }
    (5) function -> FUNCTION ID . ( argument ) { block RETURN }

    (               shift and go to state 54


state 27

    (10) block -> statement block .

    $end            reduce using rule 10 (block -> statement block .)
    }               reduce using rule 10 (block -> statement block .)
    RETURN          reduce using rule 10 (block -> statement block .)


state 28

    (21) declaration -> VARIABLE ID .
    (22) initialization -> VARIABLE ID . = boolean

    VARIABLE        reduce using rule 21 (declaration -> VARIABLE ID .)
    ID              reduce using rule 21 (declaration -> VARIABLE ID .)
    WHILE           reduce using rule 21 (declaration -> VARIABLE ID .)
    FOR             reduce using rule 21 (declaration -> VARIABLE ID .)
    IF              reduce using rule 21 (declaration -> VARIABLE ID .)
    PRINT           reduce using rule 21 (declaration -> VARIABLE ID .)
    $end            reduce using rule 21 (declaration -> VARIABLE ID .)
    }               reduce using rule 21 (declaration -> VARIABLE ID .)
    RETURN          reduce using rule 21 (declaration -> VARIABLE ID .)
    =               shift and go to state 55


state 29

    (23) assign -> ID = . boolean
    (44) boolean -> . boolean OR boolterm
    (45) boolean -> . boolterm
    (46) boolterm -> . boolterm AND boolterm1
    (47) boolterm -> . boolterm1
    (48) boolterm1 -> . ! boolterm2
    (49) boolterm1 -> . boolterm2
    (50) boolterm2 -> . condition
    (51) boolterm2 -> . expression
    (52) boolterm2 -> . FALSE
    (53) boolterm2 -> . TRUE
    (54) condition -> . expression > expression
    (55) condition -> . expression < expression
    (56) condition -> . expression GTEQL expression
    (57) condition -> . expression LTEQL expression
    (58) condition -> . expression NOTEQL expression
    (59) condition -> . expression BOOLEQL expression
    (60) expression -> . expression + term
    (61) expression -> . expression - term
    (62) expression -> . term
    (63) term -> . term * factor
    (64) term -> . term / factor
    (65) term -> . factor
    (66) factor -> . ID
    (67) factor -> . NUMBER
    (68) factor -> . STRING
    (69) factor -> . ( expression )
    (70) factor -> . ternary
    (72) factor -> . funcall
    (71) ternary -> . ( boolean ) ? ( boolean : boolean )
    (28) funcall -> . ID ( paramlist )

    !               shift and go to state 36
    FALSE           shift and go to state 40
    TRUE            shift and go to state 41
    ID              shift and go to state 44
    NUMBER          shift and go to state 45
    STRING          shift and go to state 46
    (               shift and go to state 47

    boolean                        shift and go to state 56
    boolterm                       shift and go to state 34
    boolterm1                      shift and go to state 35
    boolterm2                      shift and go to state 37
    condition                      shift and go to state 38
    expression                     shift and go to state 39
    term                           shift and go to state 42
    factor                         shift and go to state 43
    ternary                        shift and go to state 48
    funcall                        shift and go to state 49

state 30

    (28) funcall -> ID ( . paramlist )
    (29) paramlist -> . boolean , paramlist
    (30) paramlist -> . boolean
    (31) paramlist -> . empty
    (44) boolean -> . boolean OR boolterm
    (45) boolean -> . boolterm
    (9) empty -> .
    (46) boolterm -> . boolterm AND boolterm1
    (47) boolterm -> . boolterm1
    (48) boolterm1 -> . ! boolterm2
    (49) boolterm1 -> . boolterm2
    (50) boolterm2 -> . condition
    (51) boolterm2 -> . expression
    (52) boolterm2 -> . FALSE
    (53) boolterm2 -> . TRUE
    (54) condition -> . expression > expression
    (55) condition -> . expression < expression
    (56) condition -> . expression GTEQL expression
    (57) condition -> . expression LTEQL expression
    (58) condition -> . expression NOTEQL expression
    (59) condition -> . expression BOOLEQL expression
    (60) expression -> . expression + term
    (61) expression -> . expression - term
    (62) expression -> . term
    (63) term -> . term * factor
    (64) term -> . term / factor
    (65) term -> . factor
    (66) factor -> . ID
    (67) factor -> . NUMBER
    (68) factor -> . STRING
    (69) factor -> . ( expression )
    (70) factor -> . ternary
    (72) factor -> . funcall
    (71) ternary -> . ( boolean ) ? ( boolean : boolean )
    (28) funcall -> . ID ( paramlist )

    )               reduce using rule 9 (empty -> .)
    !               shift and go to state 36
    FALSE           shift and go to state 40
    TRUE            shift and go to state 41
    ID              shift and go to state 44
    NUMBER          shift and go to state 45
    STRING          shift and go to state 46
    (               shift and go to state 47

    paramlist                      shift and go to state 57
    boolean                        shift and go to state 58
    empty                          shift and go to state 59
    boolterm                       shift and go to state 34
    boolterm1                      shift and go to state 35
    boolterm2                      shift and go to state 37
    condition                      shift and go to state 38
    expression                     shift and go to state 39
    term                           shift and go to state 42
    factor                         shift and go to state 43
    ternary                        shift and go to state 48
    funcall                        shift and go to state 49

state 31

    (26) increment -> ID INCRMNT .

    VARIABLE        reduce using rule 26 (increment -> ID INCRMNT .)
    ID              reduce using rule 26 (increment -> ID INCRMNT .)
    WHILE           reduce using rule 26 (increment -> ID INCRMNT .)
    FOR             reduce using rule 26 (increment -> ID INCRMNT .)
    IF              reduce using rule 26 (increment -> ID INCRMNT .)
    PRINT           reduce using rule 26 (increment -> ID INCRMNT .)
    $end            reduce using rule 26 (increment -> ID INCRMNT .)
    }               reduce using rule 26 (increment -> ID INCRMNT .)
    RETURN          reduce using rule 26 (increment -> ID INCRMNT .)
    )               reduce using rule 26 (increment -> ID INCRMNT .)


state 32

    (27) decrement -> ID DECRMNT .

    VARIABLE        reduce using rule 27 (decrement -> ID DECRMNT .)
    ID              reduce using rule 27 (decrement -> ID DECRMNT .)
    WHILE           reduce using rule 27 (decrement -> ID DECRMNT .)
    FOR             reduce using rule 27 (decrement -> ID DECRMNT .)
    IF              reduce using rule 27 (decrement -> ID DECRMNT .)
    PRINT           reduce using rule 27 (decrement -> ID DECRMNT .)
    $end            reduce using rule 27 (decrement -> ID DECRMNT .)
    }               reduce using rule 27 (decrement -> ID DECRMNT .)
    RETURN          reduce using rule 27 (decrement -> ID DECRMNT .)
    )               reduce using rule 27 (decrement -> ID DECRMNT .)


state 33

    (36) while -> WHILE boolean . { block }
    (44) boolean -> boolean . OR boolterm

    {               shift and go to state 60
    OR              shift and go to state 61


state 34

    (45) boolean -> boolterm .
    (46) boolterm -> boolterm . AND boolterm1

    {               reduce using rule 45 (boolean -> boolterm .)
    OR              reduce using rule 45 (boolean -> boolterm .)
    VARIABLE        reduce using rule 45 (boolean -> boolterm .)
    ID              reduce using rule 45 (boolean -> boolterm .)
    WHILE           reduce using rule 45 (boolean -> boolterm .)
    FOR             reduce using rule 45 (boolean -> boolterm .)
    IF              reduce using rule 45 (boolean -> boolterm .)
    PRINT           reduce using rule 45 (boolean -> boolterm .)
    $end            reduce using rule 45 (boolean -> boolterm .)
    }               reduce using rule 45 (boolean -> boolterm .)
    RETURN          reduce using rule 45 (boolean -> boolterm .)
    )               reduce using rule 45 (boolean -> boolterm .)
    ,               reduce using rule 45 (boolean -> boolterm .)
    :               reduce using rule 45 (boolean -> boolterm .)
    AND             shift and go to state 62


state 35

    (47) boolterm -> boolterm1 .

    AND             reduce using rule 47 (boolterm -> boolterm1 .)
    {               reduce using rule 47 (boolterm -> boolterm1 .)
    OR              reduce using rule 47 (boolterm -> boolterm1 .)
    VARIABLE        reduce using rule 47 (boolterm -> boolterm1 .)
    ID              reduce using rule 47 (boolterm -> boolterm1 .)
    WHILE           reduce using rule 47 (boolterm -> boolterm1 .)
    FOR             reduce using rule 47 (boolterm -> boolterm1 .)
    IF              reduce using rule 47 (boolterm -> boolterm1 .)
    PRINT           reduce using rule 47 (boolterm -> boolterm1 .)
    $end            reduce using rule 47 (boolterm -> boolterm1 .)
    }               reduce using rule 47 (boolterm -> boolterm1 .)
    RETURN          reduce using rule 47 (boolterm -> boolterm1 .)
    )               reduce using rule 47 (boolterm -> boolterm1 .)
    ,               reduce using rule 47 (boolterm -> boolterm1 .)
    :               reduce using rule 47 (boolterm -> boolterm1 .)


state 36

    (48) boolterm1 -> ! . boolterm2
    (50) boolterm2 -> . condition
    (51) boolterm2 -> . expression
    (52) boolterm2 -> . FALSE
    (53) boolterm2 -> . TRUE
    (54) condition -> . expression > expression
    (55) condition -> . expression < expression
    (56) condition -> . expression GTEQL expression
    (57) condition -> . expression LTEQL expression
    (58) condition -> . expression NOTEQL expression
    (59) condition -> . expression BOOLEQL expression
    (60) expression -> . expression + term
    (61) expression -> . expression - term
    (62) expression -> . term
    (63) term -> . term * factor
    (64) term -> . term / factor
    (65) term -> . factor
    (66) factor -> . ID
    (67) factor -> . NUMBER
    (68) factor -> . STRING
    (69) factor -> . ( expression )
    (70) factor -> . ternary
    (72) factor -> . funcall
    (71) ternary -> . ( boolean ) ? ( boolean : boolean )
    (28) funcall -> . ID ( paramlist )

    FALSE           shift and go to state 40
    TRUE            shift and go to state 41
    ID              shift and go to state 44
    NUMBER          shift and go to state 45
    STRING          shift and go to state 46
    (               shift and go to state 47

    boolterm2                      shift and go to state 63
    condition                      shift and go to state 38
    expression                     shift and go to state 39
    term                           shift and go to state 42
    factor                         shift and go to state 43
    ternary                        shift and go to state 48
    funcall                        shift and go to state 49

state 37

    (49) boolterm1 -> boolterm2 .

    AND             reduce using rule 49 (boolterm1 -> boolterm2 .)
    {               reduce using rule 49 (boolterm1 -> boolterm2 .)
    OR              reduce using rule 49 (boolterm1 -> boolterm2 .)
    VARIABLE        reduce using rule 49 (boolterm1 -> boolterm2 .)
    ID              reduce using rule 49 (boolterm1 -> boolterm2 .)
    WHILE           reduce using rule 49 (boolterm1 -> boolterm2 .)
    FOR             reduce using rule 49 (boolterm1 -> boolterm2 .)
    IF              reduce using rule 49 (boolterm1 -> boolterm2 .)
    PRINT           reduce using rule 49 (boolterm1 -> boolterm2 .)
    $end            reduce using rule 49 (boolterm1 -> boolterm2 .)
    }               reduce using rule 49 (boolterm1 -> boolterm2 .)
    RETURN          reduce using rule 49 (boolterm1 -> boolterm2 .)
    )               reduce using rule 49 (boolterm1 -> boolterm2 .)
    ,               reduce using rule 49 (boolterm1 -> boolterm2 .)
    :               reduce using rule 49 (boolterm1 -> boolterm2 .)


state 38

    (50) boolterm2 -> condition .

    AND             reduce using rule 50 (boolterm2 -> condition .)
    {               reduce using rule 50 (boolterm2 -> condition .)
    OR              reduce using rule 50 (boolterm2 -> condition .)
    VARIABLE        reduce using rule 50 (boolterm2 -> condition .)
    ID              reduce using rule 50 (boolterm2 -> condition .)
    WHILE           reduce using rule 50 (boolterm2 -> condition .)
    FOR             reduce using rule 50 (boolterm2 -> condition .)
    IF              reduce using rule 50 (boolterm2 -> condition .)
    PRINT           reduce using rule 50 (boolterm2 -> condition .)
    $end            reduce using rule 50 (boolterm2 -> condition .)
    }               reduce using rule 50 (boolterm2 -> condition .)
    RETURN          reduce using rule 50 (boolterm2 -> condition .)
    )               reduce using rule 50 (boolterm2 -> condition .)
    ,               reduce using rule 50 (boolterm2 -> condition .)
    :               reduce using rule 50 (boolterm2 -> condition .)


state 39

    (51) boolterm2 -> expression .
    (54) condition -> expression . > expression
    (55) condition -> expression . < expression
    (56) condition -> expression . GTEQL expression
    (57) condition -> expression . LTEQL expression
    (58) condition -> expression . NOTEQL expression
    (59) condition -> expression . BOOLEQL expression
    (60) expression -> expression . + term
    (61) expression -> expression . - term

    AND             reduce using rule 51 (boolterm2 -> expression .)
    {               reduce using rule 51 (boolterm2 -> expression .)
    OR              reduce using rule 51 (boolterm2 -> expression .)
    VARIABLE        reduce using rule 51 (boolterm2 -> expression .)
    ID              reduce using rule 51 (boolterm2 -> expression .)
    WHILE           reduce using rule 51 (boolterm2 -> expression .)
    FOR             reduce using rule 51 (boolterm2 -> expression .)
    IF              reduce using rule 51 (boolterm2 -> expression .)
    PRINT           reduce using rule 51 (boolterm2 -> expression .)
    $end            reduce using rule 51 (boolterm2 -> expression .)
    }               reduce using rule 51 (boolterm2 -> expression .)
    RETURN          reduce using rule 51 (boolterm2 -> expression .)
    )               reduce using rule 51 (boolterm2 -> expression .)
    ,               reduce using rule 51 (boolterm2 -> expression .)
    :               reduce using rule 51 (boolterm2 -> expression .)
    >               shift and go to state 64
    <               shift and go to state 65
    GTEQL           shift and go to state 66
    LTEQL           shift and go to state 67
    NOTEQL          shift and go to state 68
    BOOLEQL         shift and go to state 69
    +               shift and go to state 70
    -               shift and go to state 71


state 40

    (52) boolterm2 -> FALSE .

    AND             reduce using rule 52 (boolterm2 -> FALSE .)
    {               reduce using rule 52 (boolterm2 -> FALSE .)
    OR              reduce using rule 52 (boolterm2 -> FALSE .)
    VARIABLE        reduce using rule 52 (boolterm2 -> FALSE .)
    ID              reduce using rule 52 (boolterm2 -> FALSE .)
    WHILE           reduce using rule 52 (boolterm2 -> FALSE .)
    FOR             reduce using rule 52 (boolterm2 -> FALSE .)
    IF              reduce using rule 52 (boolterm2 -> FALSE .)
    PRINT           reduce using rule 52 (boolterm2 -> FALSE .)
    $end            reduce using rule 52 (boolterm2 -> FALSE .)
    }               reduce using rule 52 (boolterm2 -> FALSE .)
    RETURN          reduce using rule 52 (boolterm2 -> FALSE .)
    )               reduce using rule 52 (boolterm2 -> FALSE .)
    ,               reduce using rule 52 (boolterm2 -> FALSE .)
    :               reduce using rule 52 (boolterm2 -> FALSE .)


state 41

    (53) boolterm2 -> TRUE .

    AND             reduce using rule 53 (boolterm2 -> TRUE .)
    {               reduce using rule 53 (boolterm2 -> TRUE .)
    OR              reduce using rule 53 (boolterm2 -> TRUE .)
    VARIABLE        reduce using rule 53 (boolterm2 -> TRUE .)
    ID              reduce using rule 53 (boolterm2 -> TRUE .)
    WHILE           reduce using rule 53 (boolterm2 -> TRUE .)
    FOR             reduce using rule 53 (boolterm2 -> TRUE .)
    IF              reduce using rule 53 (boolterm2 -> TRUE .)
    PRINT           reduce using rule 53 (boolterm2 -> TRUE .)
    $end            reduce using rule 53 (boolterm2 -> TRUE .)
    }               reduce using rule 53 (boolterm2 -> TRUE .)
    RETURN          reduce using rule 53 (boolterm2 -> TRUE .)
    )               reduce using rule 53 (boolterm2 -> TRUE .)
    ,               reduce using rule 53 (boolterm2 -> TRUE .)
    :               reduce using rule 53 (boolterm2 -> TRUE .)


state 42

    (62) expression -> term .
    (63) term -> term . * factor
    (64) term -> term . / factor

    >               reduce using rule 62 (expression -> term .)
    <               reduce using rule 62 (expression -> term .)
    GTEQL           reduce using rule 62 (expression -> term .)
    LTEQL           reduce using rule 62 (expression -> term .)
    NOTEQL          reduce using rule 62 (expression -> term .)
    BOOLEQL         reduce using rule 62 (expression -> term .)
    +               reduce using rule 62 (expression -> term .)
    -               reduce using rule 62 (expression -> term .)
    AND             reduce using rule 62 (expression -> term .)
    {               reduce using rule 62 (expression -> term .)
    OR              reduce using rule 62 (expression -> term .)
    VARIABLE        reduce using rule 62 (expression -> term .)
    ID              reduce using rule 62 (expression -> term .)
    WHILE           reduce using rule 62 (expression -> term .)
    FOR             reduce using rule 62 (expression -> term .)
    IF              reduce using rule 62 (expression -> term .)
    PRINT           reduce using rule 62 (expression -> term .)
    $end            reduce using rule 62 (expression -> term .)
    }               reduce using rule 62 (expression -> term .)
    RETURN          reduce using rule 62 (expression -> term .)
    )               reduce using rule 62 (expression -> term .)
    ,               reduce using rule 62 (expression -> term .)
    :               reduce using rule 62 (expression -> term .)
    *               shift and go to state 72
    /               shift and go to state 73


state 43

    (65) term -> factor .

    *               reduce using rule 65 (term -> factor .)
    /               reduce using rule 65 (term -> factor .)
    >               reduce using rule 65 (term -> factor .)
    <               reduce using rule 65 (term -> factor .)
    GTEQL           reduce using rule 65 (term -> factor .)
    LTEQL           reduce using rule 65 (term -> factor .)
    NOTEQL          reduce using rule 65 (term -> factor .)
    BOOLEQL         reduce using rule 65 (term -> factor .)
    +               reduce using rule 65 (term -> factor .)
    -               reduce using rule 65 (term -> factor .)
    AND             reduce using rule 65 (term -> factor .)
    {               reduce using rule 65 (term -> factor .)
    OR              reduce using rule 65 (term -> factor .)
    VARIABLE        reduce using rule 65 (term -> factor .)
    ID              reduce using rule 65 (term -> factor .)
    WHILE           reduce using rule 65 (term -> factor .)
    FOR             reduce using rule 65 (term -> factor .)
    IF              reduce using rule 65 (term -> factor .)
    PRINT           reduce using rule 65 (term -> factor .)
    $end            reduce using rule 65 (term -> factor .)
    }               reduce using rule 65 (term -> factor .)
    RETURN          reduce using rule 65 (term -> factor .)
    )               reduce using rule 65 (term -> factor .)
    ,               reduce using rule 65 (term -> factor .)
    :               reduce using rule 65 (term -> factor .)


state 44

    (66) factor -> ID .
    (28) funcall -> ID . ( paramlist )

    *               reduce using rule 66 (factor -> ID .)
    /               reduce using rule 66 (factor -> ID .)
    >               reduce using rule 66 (factor -> ID .)
    <               reduce using rule 66 (factor -> ID .)
    GTEQL           reduce using rule 66 (factor -> ID .)
    LTEQL           reduce using rule 66 (factor -> ID .)
    NOTEQL          reduce using rule 66 (factor -> ID .)
    BOOLEQL         reduce using rule 66 (factor -> ID .)
    +               reduce using rule 66 (factor -> ID .)
    -               reduce using rule 66 (factor -> ID .)
    AND             reduce using rule 66 (factor -> ID .)
    {               reduce using rule 66 (factor -> ID .)
    OR              reduce using rule 66 (factor -> ID .)
    VARIABLE        reduce using rule 66 (factor -> ID .)
    ID              reduce using rule 66 (factor -> ID .)
    WHILE           reduce using rule 66 (factor -> ID .)
    FOR             reduce using rule 66 (factor -> ID .)
    IF              reduce using rule 66 (factor -> ID .)
    PRINT           reduce using rule 66 (factor -> ID .)
    $end            reduce using rule 66 (factor -> ID .)
    }               reduce using rule 66 (factor -> ID .)
    RETURN          reduce using rule 66 (factor -> ID .)
    )               reduce using rule 66 (factor -> ID .)
    ,               reduce using rule 66 (factor -> ID .)
    :               reduce using rule 66 (factor -> ID .)
    (               shift and go to state 30


state 45

    (67) factor -> NUMBER .

    *               reduce using rule 67 (factor -> NUMBER .)
    /               reduce using rule 67 (factor -> NUMBER .)
    >               reduce using rule 67 (factor -> NUMBER .)
    <               reduce using rule 67 (factor -> NUMBER .)
    GTEQL           reduce using rule 67 (factor -> NUMBER .)
    LTEQL           reduce using rule 67 (factor -> NUMBER .)
    NOTEQL          reduce using rule 67 (factor -> NUMBER .)
    BOOLEQL         reduce using rule 67 (factor -> NUMBER .)
    +               reduce using rule 67 (factor -> NUMBER .)
    -               reduce using rule 67 (factor -> NUMBER .)
    AND             reduce using rule 67 (factor -> NUMBER .)
    {               reduce using rule 67 (factor -> NUMBER .)
    OR              reduce using rule 67 (factor -> NUMBER .)
    VARIABLE        reduce using rule 67 (factor -> NUMBER .)
    ID              reduce using rule 67 (factor -> NUMBER .)
    WHILE           reduce using rule 67 (factor -> NUMBER .)
    FOR             reduce using rule 67 (factor -> NUMBER .)
    IF              reduce using rule 67 (factor -> NUMBER .)
    PRINT           reduce using rule 67 (factor -> NUMBER .)
    $end            reduce using rule 67 (factor -> NUMBER .)
    }               reduce using rule 67 (factor -> NUMBER .)
    RETURN          reduce using rule 67 (factor -> NUMBER .)
    )               reduce using rule 67 (factor -> NUMBER .)
    ,               reduce using rule 67 (factor -> NUMBER .)
    :               reduce using rule 67 (factor -> NUMBER .)


state 46

    (68) factor -> STRING .

    *               reduce using rule 68 (factor -> STRING .)
    /               reduce using rule 68 (factor -> STRING .)
    >               reduce using rule 68 (factor -> STRING .)
    <               reduce using rule 68 (factor -> STRING .)
    GTEQL           reduce using rule 68 (factor -> STRING .)
    LTEQL           reduce using rule 68 (factor -> STRING .)
    NOTEQL          reduce using rule 68 (factor -> STRING .)
    BOOLEQL         reduce using rule 68 (factor -> STRING .)
    +               reduce using rule 68 (factor -> STRING .)
    -               reduce using rule 68 (factor -> STRING .)
    AND             reduce using rule 68 (factor -> STRING .)
    {               reduce using rule 68 (factor -> STRING .)
    OR              reduce using rule 68 (factor -> STRING .)
    VARIABLE        reduce using rule 68 (factor -> STRING .)
    ID              reduce using rule 68 (factor -> STRING .)
    WHILE           reduce using rule 68 (factor -> STRING .)
    FOR             reduce using rule 68 (factor -> STRING .)
    IF              reduce using rule 68 (factor -> STRING .)
    PRINT           reduce using rule 68 (factor -> STRING .)
    $end            reduce using rule 68 (factor -> STRING .)
    }               reduce using rule 68 (factor -> STRING .)
    RETURN          reduce using rule 68 (factor -> STRING .)
    )               reduce using rule 68 (factor -> STRING .)
    ,               reduce using rule 68 (factor -> STRING .)
    :               reduce using rule 68 (factor -> STRING .)


state 47

    (69) factor -> ( . expression )
    (71) ternary -> ( . boolean ) ? ( boolean : boolean )
    (60) expression -> . expression + term
    (61) expression -> . expression - term
    (62) expression -> . term
    (44) boolean -> . boolean OR boolterm
    (45) boolean -> . boolterm
    (63) term -> . term * factor
    (64) term -> . term / factor
    (65) term -> . factor
    (46) boolterm -> . boolterm AND boolterm1
    (47) boolterm -> . boolterm1
    (66) factor -> . ID
    (67) factor -> . NUMBER
    (68) factor -> . STRING
    (69) factor -> . ( expression )
    (70) factor -> . ternary
    (72) factor -> . funcall
    (48) boolterm1 -> . ! boolterm2
    (49) boolterm1 -> . boolterm2
    (71) ternary -> . ( boolean ) ? ( boolean : boolean )
    (28) funcall -> . ID ( paramlist )
    (50) boolterm2 -> . condition
    (51) boolterm2 -> . expression
    (52) boolterm2 -> . FALSE
    (53) boolterm2 -> . TRUE
    (54) condition -> . expression > expression
    (55) condition -> . expression < expression
    (56) condition -> . expression GTEQL expression
    (57) condition -> . expression LTEQL expression
    (58) condition -> . expression NOTEQL expression
    (59) condition -> . expression BOOLEQL expression

    ID              shift and go to state 44
    NUMBER          shift and go to state 45
    STRING          shift and go to state 46
    (               shift and go to state 47
    !               shift and go to state 36
    FALSE           shift and go to state 40
    TRUE            shift and go to state 41

    expression                     shift and go to state 74
    boolean                        shift and go to state 75
    term                           shift and go to state 42
    boolterm                       shift and go to state 34
    factor                         shift and go to state 43
    boolterm1                      shift and go to state 35
    ternary                        shift and go to state 48
    funcall                        shift and go to state 49
    boolterm2                      shift and go to state 37
    condition                      shift and go to state 38

state 48

    (70) factor -> ternary .

    *               reduce using rule 70 (factor -> ternary .)
    /               reduce using rule 70 (factor -> ternary .)
    >               reduce using rule 70 (factor -> ternary .)
    <               reduce using rule 70 (factor -> ternary .)
    GTEQL           reduce using rule 70 (factor -> ternary .)
    LTEQL           reduce using rule 70 (factor -> ternary .)
    NOTEQL          reduce using rule 70 (factor -> ternary .)
    BOOLEQL         reduce using rule 70 (factor -> ternary .)
    +               reduce using rule 70 (factor -> ternary .)
    -               reduce using rule 70 (factor -> ternary .)
    AND             reduce using rule 70 (factor -> ternary .)
    {               reduce using rule 70 (factor -> ternary .)
    OR              reduce using rule 70 (factor -> ternary .)
    VARIABLE        reduce using rule 70 (factor -> ternary .)
    ID              reduce using rule 70 (factor -> ternary .)
    WHILE           reduce using rule 70 (factor -> ternary .)
    FOR             reduce using rule 70 (factor -> ternary .)
    IF              reduce using rule 70 (factor -> ternary .)
    PRINT           reduce using rule 70 (factor -> ternary .)
    $end            reduce using rule 70 (factor -> ternary .)
    }               reduce using rule 70 (factor -> ternary .)
    RETURN          reduce using rule 70 (factor -> ternary .)
    )               reduce using rule 70 (factor -> ternary .)
    ,               reduce using rule 70 (factor -> ternary .)
    :               reduce using rule 70 (factor -> ternary .)


state 49

    (72) factor -> funcall .

    *               reduce using rule 72 (factor -> funcall .)
    /               reduce using rule 72 (factor -> funcall .)
    >               reduce using rule 72 (factor -> funcall .)
    <               reduce using rule 72 (factor -> funcall .)
    GTEQL           reduce using rule 72 (factor -> funcall .)
    LTEQL           reduce using rule 72 (factor -> funcall .)
    NOTEQL          reduce using rule 72 (factor -> funcall .)
    BOOLEQL         reduce using rule 72 (factor -> funcall .)
    +               reduce using rule 72 (factor -> funcall .)
    -               reduce using rule 72 (factor -> funcall .)
    AND             reduce using rule 72 (factor -> funcall .)
    {               reduce using rule 72 (factor -> funcall .)
    OR              reduce using rule 72 (factor -> funcall .)
    VARIABLE        reduce using rule 72 (factor -> funcall .)
    ID              reduce using rule 72 (factor -> funcall .)
    WHILE           reduce using rule 72 (factor -> funcall .)
    FOR             reduce using rule 72 (factor -> funcall .)
    IF              reduce using rule 72 (factor -> funcall .)
    PRINT           reduce using rule 72 (factor -> funcall .)
    $end            reduce using rule 72 (factor -> funcall .)
    }               reduce using rule 72 (factor -> funcall .)
    RETURN          reduce using rule 72 (factor -> funcall .)
    )               reduce using rule 72 (factor -> funcall .)
    ,               reduce using rule 72 (factor -> funcall .)
    :               reduce using rule 72 (factor -> funcall .)


state 50

    (37) for -> FOR ( . initialization , boolean , assign ) { block }
    (38) for -> FOR ( . initialization , boolean , unary ) { block }
    (22) initialization -> . VARIABLE ID = boolean

    VARIABLE        shift and go to state 77

    initialization                 shift and go to state 76

state 51

    (39) for -> FOR ID . IN RANGE ( expression , expression ) { block }

    IN              shift and go to state 78


state 52

    (32) if -> IF boolean . { block } elif
    (44) boolean -> boolean . OR boolterm

    {               shift and go to state 79
    OR              shift and go to state 61


state 53

    (40) print -> PRINT ( . plist )
    (41) plist -> . pstat , plist
    (42) plist -> . pstat
    (43) pstat -> . boolean
    (44) boolean -> . boolean OR boolterm
    (45) boolean -> . boolterm
    (46) boolterm -> . boolterm AND boolterm1
    (47) boolterm -> . boolterm1
    (48) boolterm1 -> . ! boolterm2
    (49) boolterm1 -> . boolterm2
    (50) boolterm2 -> . condition
    (51) boolterm2 -> . expression
    (52) boolterm2 -> . FALSE
    (53) boolterm2 -> . TRUE
    (54) condition -> . expression > expression
    (55) condition -> . expression < expression
    (56) condition -> . expression GTEQL expression
    (57) condition -> . expression LTEQL expression
    (58) condition -> . expression NOTEQL expression
    (59) condition -> . expression BOOLEQL expression
    (60) expression -> . expression + term
    (61) expression -> . expression - term
    (62) expression -> . term
    (63) term -> . term * factor
    (64) term -> . term / factor
    (65) term -> . factor
    (66) factor -> . ID
    (67) factor -> . NUMBER
    (68) factor -> . STRING
    (69) factor -> . ( expression )
    (70) factor -> . ternary
    (72) factor -> . funcall
    (71) ternary -> . ( boolean ) ? ( boolean : boolean )
    (28) funcall -> . ID ( paramlist )

    !               shift and go to state 36
    FALSE           shift and go to state 40
    TRUE            shift and go to state 41
    ID              shift and go to state 44
    NUMBER          shift and go to state 45
    STRING          shift and go to state 46
    (               shift and go to state 47

    plist                          shift and go to state 80
    pstat                          shift and go to state 81
    boolean                        shift and go to state 82
    boolterm                       shift and go to state 34
    boolterm1                      shift and go to state 35
    boolterm2                      shift and go to state 37
    condition                      shift and go to state 38
    expression                     shift and go to state 39
    term                           shift and go to state 42
    factor                         shift and go to state 43
    ternary                        shift and go to state 48
    funcall                        shift and go to state 49

state 54

    (4) function -> FUNCTION ID ( . argument ) { block RETURN boolean }
    (5) function -> FUNCTION ID ( . argument ) { block RETURN }
    (6) argument -> . ID , argument
    (7) argument -> . ID
    (8) argument -> . empty
    (9) empty -> .

    ID              shift and go to state 83
    )               reduce using rule 9 (empty -> .)

    argument                       shift and go to state 84
    empty                          shift and go to state 85

state 55

    (22) initialization -> VARIABLE ID = . boolean
    (44) boolean -> . boolean OR boolterm
    (45) boolean -> . boolterm
    (46) boolterm -> . boolterm AND boolterm1
    (47) boolterm -> . boolterm1
    (48) boolterm1 -> . ! boolterm2
    (49) boolterm1 -> . boolterm2
    (50) boolterm2 -> . condition
    (51) boolterm2 -> . expression
    (52) boolterm2 -> . FALSE
    (53) boolterm2 -> . TRUE
    (54) condition -> . expression > expression
    (55) condition -> . expression < expression
    (56) condition -> . expression GTEQL expression
    (57) condition -> . expression LTEQL expression
    (58) condition -> . expression NOTEQL expression
    (59) condition -> . expression BOOLEQL expression
    (60) expression -> . expression + term
    (61) expression -> . expression - term
    (62) expression -> . term
    (63) term -> . term * factor
    (64) term -> . term / factor
    (65) term -> . factor
    (66) factor -> . ID
    (67) factor -> . NUMBER
    (68) factor -> . STRING
    (69) factor -> . ( expression )
    (70) factor -> . ternary
    (72) factor -> . funcall
    (71) ternary -> . ( boolean ) ? ( boolean : boolean )
    (28) funcall -> . ID ( paramlist )

    !               shift and go to state 36
    FALSE           shift and go to state 40
    TRUE            shift and go to state 41
    ID              shift and go to state 44
    NUMBER          shift and go to state 45
    STRING          shift and go to state 46
    (               shift and go to state 47

    boolean                        shift and go to state 86
    boolterm                       shift and go to state 34
    boolterm1                      shift and go to state 35
    boolterm2                      shift and go to state 37
    condition                      shift and go to state 38
    expression                     shift and go to state 39
    term                           shift and go to state 42
    factor                         shift and go to state 43
    ternary                        shift and go to state 48
    funcall                        shift and go to state 49

state 56

    (23) assign -> ID = boolean .
    (44) boolean -> boolean . OR boolterm

    VARIABLE        reduce using rule 23 (assign -> ID = boolean .)
    ID              reduce using rule 23 (assign -> ID = boolean .)
    WHILE           reduce using rule 23 (assign -> ID = boolean .)
    FOR             reduce using rule 23 (assign -> ID = boolean .)
    IF              reduce using rule 23 (assign -> ID = boolean .)
    PRINT           reduce using rule 23 (assign -> ID = boolean .)
    $end            reduce using rule 23 (assign -> ID = boolean .)
    }               reduce using rule 23 (assign -> ID = boolean .)
    RETURN          reduce using rule 23 (assign -> ID = boolean .)
    )               reduce using rule 23 (assign -> ID = boolean .)
    OR              shift and go to state 61


state 57

    (28) funcall -> ID ( paramlist . )

    )               shift and go to state 87


state 58

    (29) paramlist -> boolean . , paramlist
    (30) paramlist -> boolean .
    (44) boolean -> boolean . OR boolterm

    ,               shift and go to state 88
    )               reduce using rule 30 (paramlist -> boolean .)
    OR              shift and go to state 61


state 59

    (31) paramlist -> empty .

    )               reduce using rule 31 (paramlist -> empty .)


state 60

    (36) while -> WHILE boolean { . block }
    (10) block -> . statement block
    (11) block -> . statement
    (12) statement -> . declaration
    (13) statement -> . initialization
    (14) statement -> . assign
    (15) statement -> . funcall
    (16) statement -> . unary
    (17) statement -> . while
    (18) statement -> . for
    (19) statement -> . if
    (20) statement -> . print
    (21) declaration -> . VARIABLE ID
    (22) initialization -> . VARIABLE ID = boolean
    (23) assign -> . ID = boolean
    (28) funcall -> . ID ( paramlist )
    (24) unary -> . increment
    (25) unary -> . decrement
    (36) while -> . WHILE boolean { block }
    (37) for -> . FOR ( initialization , boolean , assign ) { block }
    (38) for -> . FOR ( initialization , boolean , unary ) { block }
    (39) for -> . FOR ID IN RANGE ( expression , expression ) { block }
    (32) if -> . IF boolean { block } elif
    (40) print -> . PRINT ( plist )
    (26) increment -> . ID INCRMNT
    (27) decrement -> . ID DECRMNT

    VARIABLE        shift and go to state 17
    ID              shift and go to state 18
    WHILE           shift and go to state 21
    FOR             shift and go to state 22
    IF              shift and go to state 23
    PRINT           shift and go to state 24

    block                          shift and go to state 89
    statement                      shift and go to state 7
    declaration                    shift and go to state 8
    initialization                 shift and go to state 9
    assign                         shift and go to state 10
    funcall                        shift and go to state 11
    unary                          shift and go to state 12
    while                          shift and go to state 13
    for                            shift and go to state 14
    if                             shift and go to state 15
    print                          shift and go to state 16
    increment                      shift and go to state 19
    decrement                      shift and go to state 20

state 61

    (44) boolean -> boolean OR . boolterm
    (46) boolterm -> . boolterm AND boolterm1
    (47) boolterm -> . boolterm1
    (48) boolterm1 -> . ! boolterm2
    (49) boolterm1 -> . boolterm2
    (50) boolterm2 -> . condition
    (51) boolterm2 -> . expression
    (52) boolterm2 -> . FALSE
    (53) boolterm2 -> . TRUE
    (54) condition -> . expression > expression
    (55) condition -> . expression < expression
    (56) condition -> . expression GTEQL expression
    (57) condition -> . expression LTEQL expression
    (58) condition -> . expression NOTEQL expression
    (59) condition -> . expression BOOLEQL expression
    (60) expression -> . expression + term
    (61) expression -> . expression - term
    (62) expression -> . term
    (63) term -> . term * factor
    (64) term -> . term / factor
    (65) term -> . factor
    (66) factor -> . ID
    (67) factor -> . NUMBER
    (68) factor -> . STRING
    (69) factor -> . ( expression )
    (70) factor -> . ternary
    (72) factor -> . funcall
    (71) ternary -> . ( boolean ) ? ( boolean : boolean )
    (28) funcall -> . ID ( paramlist )

    !               shift and go to state 36
    FALSE           shift and go to state 40
    TRUE            shift and go to state 41
    ID              shift and go to state 44
    NUMBER          shift and go to state 45
    STRING          shift and go to state 46
    (               shift and go to state 47

    boolterm                       shift and go to state 90
    boolterm1                      shift and go to state 35
    boolterm2                      shift and go to state 37
    condition                      shift and go to state 38
    expression                     shift and go to state 39
    term                           shift and go to state 42
    factor                         shift and go to state 43
    ternary                        shift and go to state 48
    funcall                        shift and go to state 49

state 62

    (46) boolterm -> boolterm AND . boolterm1
    (48) boolterm1 -> . ! boolterm2
    (49) boolterm1 -> . boolterm2
    (50) boolterm2 -> . condition
    (51) boolterm2 -> . expression
    (52) boolterm2 -> . FALSE
    (53) boolterm2 -> . TRUE
    (54) condition -> . expression > expression
    (55) condition -> . expression < expression
    (56) condition -> . expression GTEQL expression
    (57) condition -> . expression LTEQL expression
    (58) condition -> . expression NOTEQL expression
    (59) condition -> . expression BOOLEQL expression
    (60) expression -> . expression + term
    (61) expression -> . expression - term
    (62) expression -> . term
    (63) term -> . term * factor
    (64) term -> . term / factor
    (65) term -> . factor
    (66) factor -> . ID
    (67) factor -> . NUMBER
    (68) factor -> . STRING
    (69) factor -> . ( expression )
    (70) factor -> . ternary
    (72) factor -> . funcall
    (71) ternary -> . ( boolean ) ? ( boolean : boolean )
    (28) funcall -> . ID ( paramlist )

    !               shift and go to state 36
    FALSE           shift and go to state 40
    TRUE            shift and go to state 41
    ID              shift and go to state 44
    NUMBER          shift and go to state 45
    STRING          shift and go to state 46
    (               shift and go to state 47

    boolterm1                      shift and go to state 91
    boolterm2                      shift and go to state 37
    condition                      shift and go to state 38
    expression                     shift and go to state 39
    term                           shift and go to state 42
    factor                         shift and go to state 43
    ternary                        shift and go to state 48
    funcall                        shift and go to state 49

state 63

    (48) boolterm1 -> ! boolterm2 .

    AND             reduce using rule 48 (boolterm1 -> ! boolterm2 .)
    {               reduce using rule 48 (boolterm1 -> ! boolterm2 .)
    OR              reduce using rule 48 (boolterm1 -> ! boolterm2 .)
    VARIABLE        reduce using rule 48 (boolterm1 -> ! boolterm2 .)
    ID              reduce using rule 48 (boolterm1 -> ! boolterm2 .)
    WHILE           reduce using rule 48 (boolterm1 -> ! boolterm2 .)
    FOR             reduce using rule 48 (boolterm1 -> ! boolterm2 .)
    IF              reduce using rule 48 (boolterm1 -> ! boolterm2 .)
    PRINT           reduce using rule 48 (boolterm1 -> ! boolterm2 .)
    $end            reduce using rule 48 (boolterm1 -> ! boolterm2 .)
    }               reduce using rule 48 (boolterm1 -> ! boolterm2 .)
    RETURN          reduce using rule 48 (boolterm1 -> ! boolterm2 .)
    )               reduce using rule 48 (boolterm1 -> ! boolterm2 .)
    ,               reduce using rule 48 (boolterm1 -> ! boolterm2 .)
    :               reduce using rule 48 (boolterm1 -> ! boolterm2 .)


state 64

    (54) condition -> expression > . expression
    (60) expression -> . expression + term
    (61) expression -> . expression - term
    (62) expression -> . term
    (63) term -> . term * factor
    (64) term -> . term / factor
    (65) term -> . factor
    (66) factor -> . ID
    (67) factor -> . NUMBER
    (68) factor -> . STRING
    (69) factor -> . ( expression )
    (70) factor -> . ternary
    (72) factor -> . funcall
    (71) ternary -> . ( boolean ) ? ( boolean : boolean )
    (28) funcall -> . ID ( paramlist )

    ID              shift and go to state 44
    NUMBER          shift and go to state 45
    STRING          shift and go to state 46
    (               shift and go to state 47

    expression                     shift and go to state 92
    term                           shift and go to state 42
    factor                         shift and go to state 43
    ternary                        shift and go to state 48
    funcall                        shift and go to state 49

state 65

    (55) condition -> expression < . expression
    (60) expression -> . expression + term
    (61) expression -> . expression - term
    (62) expression -> . term
    (63) term -> . term * factor
    (64) term -> . term / factor
    (65) term -> . factor
    (66) factor -> . ID
    (67) factor -> . NUMBER
    (68) factor -> . STRING
    (69) factor -> . ( expression )
    (70) factor -> . ternary
    (72) factor -> . funcall
    (71) ternary -> . ( boolean ) ? ( boolean : boolean )
    (28) funcall -> . ID ( paramlist )

    ID              shift and go to state 44
    NUMBER          shift and go to state 45
    STRING          shift and go to state 46
    (               shift and go to state 47

    expression                     shift and go to state 93
    term                           shift and go to state 42
    factor                         shift and go to state 43
    ternary                        shift and go to state 48
    funcall                        shift and go to state 49

state 66

    (56) condition -> expression GTEQL . expression
    (60) expression -> . expression + term
    (61) expression -> . expression - term
    (62) expression -> . term
    (63) term -> . term * factor
    (64) term -> . term / factor
    (65) term -> . factor
    (66) factor -> . ID
    (67) factor -> . NUMBER
    (68) factor -> . STRING
    (69) factor -> . ( expression )
    (70) factor -> . ternary
    (72) factor -> . funcall
    (71) ternary -> . ( boolean ) ? ( boolean : boolean )
    (28) funcall -> . ID ( paramlist )

    ID              shift and go to state 44
    NUMBER          shift and go to state 45
    STRING          shift and go to state 46
    (               shift and go to state 47

    expression                     shift and go to state 94
    term                           shift and go to state 42
    factor                         shift and go to state 43
    ternary                        shift and go to state 48
    funcall                        shift and go to state 49

state 67

    (57) condition -> expression LTEQL . expression
    (60) expression -> . expression + term
    (61) expression -> . expression - term
    (62) expression -> . term
    (63) term -> . term * factor
    (64) term -> . term / factor
    (65) term -> . factor
    (66) factor -> . ID
    (67) factor -> . NUMBER
    (68) factor -> . STRING
    (69) factor -> . ( expression )
    (70) factor -> . ternary
    (72) factor -> . funcall
    (71) ternary -> . ( boolean ) ? ( boolean : boolean )
    (28) funcall -> . ID ( paramlist )

    ID              shift and go to state 44
    NUMBER          shift and go to state 45
    STRING          shift and go to state 46
    (               shift and go to state 47

    expression                     shift and go to state 95
    term                           shift and go to state 42
    factor                         shift and go to state 43
    ternary                        shift and go to state 48
    funcall                        shift and go to state 49

state 68

    (58) condition -> expression NOTEQL . expression
    (60) expression -> . expression + term
    (61) expression -> . expression - term
    (62) expression -> . term
    (63) term -> . term * factor
    (64) term -> . term / factor
    (65) term -> . factor
    (66) factor -> . ID
    (67) factor -> . NUMBER
    (68) factor -> . STRING
    (69) factor -> . ( expression )
    (70) factor -> . ternary
    (72) factor -> . funcall
    (71) ternary -> . ( boolean ) ? ( boolean : boolean )
    (28) funcall -> . ID ( paramlist )

    ID              shift and go to state 44
    NUMBER          shift and go to state 45
    STRING          shift and go to state 46
    (               shift and go to state 47

    expression                     shift and go to state 96
    term                           shift and go to state 42
    factor                         shift and go to state 43
    ternary                        shift and go to state 48
    funcall                        shift and go to state 49

state 69

    (59) condition -> expression BOOLEQL . expression
    (60) expression -> . expression + term
    (61) expression -> . expression - term
    (62) expression -> . term
    (63) term -> . term * factor
    (64) term -> . term / factor
    (65) term -> . factor
    (66) factor -> . ID
    (67) factor -> . NUMBER
    (68) factor -> . STRING
    (69) factor -> . ( expression )
    (70) factor -> . ternary
    (72) factor -> . funcall
    (71) ternary -> . ( boolean ) ? ( boolean : boolean )
    (28) funcall -> . ID ( paramlist )

    ID              shift and go to state 44
    NUMBER          shift and go to state 45
    STRING          shift and go to state 46
    (               shift and go to state 47

    expression                     shift and go to state 97
    term                           shift and go to state 42
    factor                         shift and go to state 43
    ternary                        shift and go to state 48
    funcall                        shift and go to state 49

state 70

    (60) expression -> expression + . term
    (63) term -> . term * factor
    (64) term -> . term / factor
    (65) term -> . factor
    (66) factor -> . ID
    (67) factor -> . NUMBER
    (68) factor -> . STRING
    (69) factor -> . ( expression )
    (70) factor -> . ternary
    (72) factor -> . funcall
    (71) ternary -> . ( boolean ) ? ( boolean : boolean )
    (28) funcall -> . ID ( paramlist )

    ID              shift and go to state 44
    NUMBER          shift and go to state 45
    STRING          shift and go to state 46
    (               shift and go to state 47

    term                           shift and go to state 98
    factor                         shift and go to state 43
    ternary                        shift and go to state 48
    funcall                        shift and go to state 49

state 71

    (61) expression -> expression - . term
    (63) term -> . term * factor
    (64) term -> . term / factor
    (65) term -> . factor
    (66) factor -> . ID
    (67) factor -> . NUMBER
    (68) factor -> . STRING
    (69) factor -> . ( expression )
    (70) factor -> . ternary
    (72) factor -> . funcall
    (71) ternary -> . ( boolean ) ? ( boolean : boolean )
    (28) funcall -> . ID ( paramlist )

    ID              shift and go to state 44
    NUMBER          shift and go to state 45
    STRING          shift and go to state 46
    (               shift and go to state 47

    term                           shift and go to state 99
    factor                         shift and go to state 43
    ternary                        shift and go to state 48
    funcall                        shift and go to state 49

state 72

    (63) term -> term * . factor
    (66) factor -> . ID
    (67) factor -> . NUMBER
    (68) factor -> . STRING
    (69) factor -> . ( expression )
    (70) factor -> . ternary
    (72) factor -> . funcall
    (71) ternary -> . ( boolean ) ? ( boolean : boolean )
    (28) funcall -> . ID ( paramlist )

    ID              shift and go to state 44
    NUMBER          shift and go to state 45
    STRING          shift and go to state 46
    (               shift and go to state 47

    factor                         shift and go to state 100
    ternary                        shift and go to state 48
    funcall                        shift and go to state 49

state 73

    (64) term -> term / . factor
    (66) factor -> . ID
    (67) factor -> . NUMBER
    (68) factor -> . STRING
    (69) factor -> . ( expression )
    (70) factor -> . ternary
    (72) factor -> . funcall
    (71) ternary -> . ( boolean ) ? ( boolean : boolean )
    (28) funcall -> . ID ( paramlist )

    ID              shift and go to state 44
    NUMBER          shift and go to state 45
    STRING          shift and go to state 46
    (               shift and go to state 47

    factor                         shift and go to state 101
    ternary                        shift and go to state 48
    funcall                        shift and go to state 49

state 74

    (69) factor -> ( expression . )
    (60) expression -> expression . + term
    (61) expression -> expression . - term
    (51) boolterm2 -> expression .
    (54) condition -> expression . > expression
    (55) condition -> expression . < expression
    (56) condition -> expression . GTEQL expression
    (57) condition -> expression . LTEQL expression
    (58) condition -> expression . NOTEQL expression
    (59) condition -> expression . BOOLEQL expression

  ! shift/reduce conflict for ) resolved as shift
    )               shift and go to state 102
    +               shift and go to state 70
    -               shift and go to state 71
    AND             reduce using rule 51 (boolterm2 -> expression .)
    OR              reduce using rule 51 (boolterm2 -> expression .)
    >               shift and go to state 64
    <               shift and go to state 65
    GTEQL           shift and go to state 66
    LTEQL           shift and go to state 67
    NOTEQL          shift and go to state 68
    BOOLEQL         shift and go to state 69

  ! )               [ reduce using rule 51 (boolterm2 -> expression .) ]


state 75

    (71) ternary -> ( boolean . ) ? ( boolean : boolean )
    (44) boolean -> boolean . OR boolterm

    )               shift and go to state 103
    OR              shift and go to state 61


state 76

    (37) for -> FOR ( initialization . , boolean , assign ) { block }
    (38) for -> FOR ( initialization . , boolean , unary ) { block }

    ,               shift and go to state 104


state 77

    (22) initialization -> VARIABLE . ID = boolean

    ID              shift and go to state 105


state 78

    (39) for -> FOR ID IN . RANGE ( expression , expression ) { block }

    RANGE           shift and go to state 106


state 79

    (32) if -> IF boolean { . block } elif
    (10) block -> . statement block
    (11) block -> . statement
    (12) statement -> . declaration
    (13) statement -> . initialization
    (14) statement -> . assign
    (15) statement -> . funcall
    (16) statement -> . unary
    (17) statement -> . while
    (18) statement -> . for
    (19) statement -> . if
    (20) statement -> . print
    (21) declaration -> . VARIABLE ID
    (22) initialization -> . VARIABLE ID = boolean
    (23) assign -> . ID = boolean
    (28) funcall -> . ID ( paramlist )
    (24) unary -> . increment
    (25) unary -> . decrement
    (36) while -> . WHILE boolean { block }
    (37) for -> . FOR ( initialization , boolean , assign ) { block }
    (38) for -> . FOR ( initialization , boolean , unary ) { block }
    (39) for -> . FOR ID IN RANGE ( expression , expression ) { block }
    (32) if -> . IF boolean { block } elif
    (40) print -> . PRINT ( plist )
    (26) increment -> . ID INCRMNT
    (27) decrement -> . ID DECRMNT

    VARIABLE        shift and go to state 17
    ID              shift and go to state 18
    WHILE           shift and go to state 21
    FOR             shift and go to state 22
    IF              shift and go to state 23
    PRINT           shift and go to state 24

    block                          shift and go to state 107
    statement                      shift and go to state 7
    declaration                    shift and go to state 8
    initialization                 shift and go to state 9
    assign                         shift and go to state 10
    funcall                        shift and go to state 11
    unary                          shift and go to state 12
    while                          shift and go to state 13
    for                            shift and go to state 14
    if                             shift and go to state 15
    print                          shift and go to state 16
    increment                      shift and go to state 19
    decrement                      shift and go to state 20

state 80

    (40) print -> PRINT ( plist . )

    )               shift and go to state 108


state 81

    (41) plist -> pstat . , plist
    (42) plist -> pstat .

    ,               shift and go to state 109
    )               reduce using rule 42 (plist -> pstat .)


state 82

    (43) pstat -> boolean .
    (44) boolean -> boolean . OR boolterm

    ,               reduce using rule 43 (pstat -> boolean .)
    )               reduce using rule 43 (pstat -> boolean .)
    OR              shift and go to state 61


state 83

    (6) argument -> ID . , argument
    (7) argument -> ID .

    ,               shift and go to state 110
    )               reduce using rule 7 (argument -> ID .)


state 84

    (4) function -> FUNCTION ID ( argument . ) { block RETURN boolean }
    (5) function -> FUNCTION ID ( argument . ) { block RETURN }

    )               shift and go to state 111


state 85

    (8) argument -> empty .

    )               reduce using rule 8 (argument -> empty .)


state 86

    (22) initialization -> VARIABLE ID = boolean .
    (44) boolean -> boolean . OR boolterm

    VARIABLE        reduce using rule 22 (initialization -> VARIABLE ID = boolean .)
    ID              reduce using rule 22 (initialization -> VARIABLE ID = boolean .)
    WHILE           reduce using rule 22 (initialization -> VARIABLE ID = boolean .)
    FOR             reduce using rule 22 (initialization -> VARIABLE ID = boolean .)
    IF              reduce using rule 22 (initialization -> VARIABLE ID = boolean .)
    PRINT           reduce using rule 22 (initialization -> VARIABLE ID = boolean .)
    $end            reduce using rule 22 (initialization -> VARIABLE ID = boolean .)
    }               reduce using rule 22 (initialization -> VARIABLE ID = boolean .)
    RETURN          reduce using rule 22 (initialization -> VARIABLE ID = boolean .)
    ,               reduce using rule 22 (initialization -> VARIABLE ID = boolean .)
    OR              shift and go to state 61


state 87

    (28) funcall -> ID ( paramlist ) .

    VARIABLE        reduce using rule 28 (funcall -> ID ( paramlist ) .)
    ID              reduce using rule 28 (funcall -> ID ( paramlist ) .)
    WHILE           reduce using rule 28 (funcall -> ID ( paramlist ) .)
    FOR             reduce using rule 28 (funcall -> ID ( paramlist ) .)
    IF              reduce using rule 28 (funcall -> ID ( paramlist ) .)
    PRINT           reduce using rule 28 (funcall -> ID ( paramlist ) .)
    $end            reduce using rule 28 (funcall -> ID ( paramlist ) .)
    }               reduce using rule 28 (funcall -> ID ( paramlist ) .)
    RETURN          reduce using rule 28 (funcall -> ID ( paramlist ) .)
    *               reduce using rule 28 (funcall -> ID ( paramlist ) .)
    /               reduce using rule 28 (funcall -> ID ( paramlist ) .)
    >               reduce using rule 28 (funcall -> ID ( paramlist ) .)
    <               reduce using rule 28 (funcall -> ID ( paramlist ) .)
    GTEQL           reduce using rule 28 (funcall -> ID ( paramlist ) .)
    LTEQL           reduce using rule 28 (funcall -> ID ( paramlist ) .)
    NOTEQL          reduce using rule 28 (funcall -> ID ( paramlist ) .)
    BOOLEQL         reduce using rule 28 (funcall -> ID ( paramlist ) .)
    +               reduce using rule 28 (funcall -> ID ( paramlist ) .)
    -               reduce using rule 28 (funcall -> ID ( paramlist ) .)
    AND             reduce using rule 28 (funcall -> ID ( paramlist ) .)
    {               reduce using rule 28 (funcall -> ID ( paramlist ) .)
    OR              reduce using rule 28 (funcall -> ID ( paramlist ) .)
    )               reduce using rule 28 (funcall -> ID ( paramlist ) .)
    ,               reduce using rule 28 (funcall -> ID ( paramlist ) .)
    :               reduce using rule 28 (funcall -> ID ( paramlist ) .)


state 88

    (29) paramlist -> boolean , . paramlist
    (29) paramlist -> . boolean , paramlist
    (30) paramlist -> . boolean
    (31) paramlist -> . empty
    (44) boolean -> . boolean OR boolterm
    (45) boolean -> . boolterm
    (9) empty -> .
    (46) boolterm -> . boolterm AND boolterm1
    (47) boolterm -> . boolterm1
    (48) boolterm1 -> . ! boolterm2
    (49) boolterm1 -> . boolterm2
    (50) boolterm2 -> . condition
    (51) boolterm2 -> . expression
    (52) boolterm2 -> . FALSE
    (53) boolterm2 -> . TRUE
    (54) condition -> . expression > expression
    (55) condition -> . expression < expression
    (56) condition -> . expression GTEQL expression
    (57) condition -> . expression LTEQL expression
    (58) condition -> . expression NOTEQL expression
    (59) condition -> . expression BOOLEQL expression
    (60) expression -> . expression + term
    (61) expression -> . expression - term
    (62) expression -> . term
    (63) term -> . term * factor
    (64) term -> . term / factor
    (65) term -> . factor
    (66) factor -> . ID
    (67) factor -> . NUMBER
    (68) factor -> . STRING
    (69) factor -> . ( expression )
    (70) factor -> . ternary
    (72) factor -> . funcall
    (71) ternary -> . ( boolean ) ? ( boolean : boolean )
    (28) funcall -> . ID ( paramlist )

    )               reduce using rule 9 (empty -> .)
    !               shift and go to state 36
    FALSE           shift and go to state 40
    TRUE            shift and go to state 41
    ID              shift and go to state 44
    NUMBER          shift and go to state 45
    STRING          shift and go to state 46
    (               shift and go to state 47

    boolean                        shift and go to state 58
    paramlist                      shift and go to state 112
    empty                          shift and go to state 59
    boolterm                       shift and go to state 34
    boolterm1                      shift and go to state 35
    boolterm2                      shift and go to state 37
    condition                      shift and go to state 38
    expression                     shift and go to state 39
    term                           shift and go to state 42
    factor                         shift and go to state 43
    ternary                        shift and go to state 48
    funcall                        shift and go to state 49

state 89

    (36) while -> WHILE boolean { block . }

    }               shift and go to state 113


state 90

    (44) boolean -> boolean OR boolterm .
    (46) boolterm -> boolterm . AND boolterm1

    {               reduce using rule 44 (boolean -> boolean OR boolterm .)
    OR              reduce using rule 44 (boolean -> boolean OR boolterm .)
    VARIABLE        reduce using rule 44 (boolean -> boolean OR boolterm .)
    ID              reduce using rule 44 (boolean -> boolean OR boolterm .)
    WHILE           reduce using rule 44 (boolean -> boolean OR boolterm .)
    FOR             reduce using rule 44 (boolean -> boolean OR boolterm .)
    IF              reduce using rule 44 (boolean -> boolean OR boolterm .)
    PRINT           reduce using rule 44 (boolean -> boolean OR boolterm .)
    $end            reduce using rule 44 (boolean -> boolean OR boolterm .)
    }               reduce using rule 44 (boolean -> boolean OR boolterm .)
    RETURN          reduce using rule 44 (boolean -> boolean OR boolterm .)
    )               reduce using rule 44 (boolean -> boolean OR boolterm .)
    ,               reduce using rule 44 (boolean -> boolean OR boolterm .)
    :               reduce using rule 44 (boolean -> boolean OR boolterm .)
    AND             shift and go to state 62


state 91

    (46) boolterm -> boolterm AND boolterm1 .

    AND             reduce using rule 46 (boolterm -> boolterm AND boolterm1 .)
    {               reduce using rule 46 (boolterm -> boolterm AND boolterm1 .)
    OR              reduce using rule 46 (boolterm -> boolterm AND boolterm1 .)
    VARIABLE        reduce using rule 46 (boolterm -> boolterm AND boolterm1 .)
    ID              reduce using rule 46 (boolterm -> boolterm AND boolterm1 .)
    WHILE           reduce using rule 46 (boolterm -> boolterm AND boolterm1 .)
    FOR             reduce using rule 46 (boolterm -> boolterm AND boolterm1 .)
    IF              reduce using rule 46 (boolterm -> boolterm AND boolterm1 .)
    PRINT           reduce using rule 46 (boolterm -> boolterm AND boolterm1 .)
    $end            reduce using rule 46 (boolterm -> boolterm AND boolterm1 .)
    }               reduce using rule 46 (boolterm -> boolterm AND boolterm1 .)
    RETURN          reduce using rule 46 (boolterm -> boolterm AND boolterm1 .)
    )               reduce using rule 46 (boolterm -> boolterm AND boolterm1 .)
    ,               reduce using rule 46 (boolterm -> boolterm AND boolterm1 .)
    :               reduce using rule 46 (boolterm -> boolterm AND boolterm1 .)


state 92

    (54) condition -> expression > expression .
    (60) expression -> expression . + term
    (61) expression -> expression . - term

    AND             reduce using rule 54 (condition -> expression > expression .)
    {               reduce using rule 54 (condition -> expression > expression .)
    OR              reduce using rule 54 (condition -> expression > expression .)
    VARIABLE        reduce using rule 54 (condition -> expression > expression .)
    ID              reduce using rule 54 (condition -> expression > expression .)
    WHILE           reduce using rule 54 (condition -> expression > expression .)
    FOR             reduce using rule 54 (condition -> expression > expression .)
    IF              reduce using rule 54 (condition -> expression > expression .)
    PRINT           reduce using rule 54 (condition -> expression > expression .)
    $end            reduce using rule 54 (condition -> expression > expression .)
    }               reduce using rule 54 (condition -> expression > expression .)
    RETURN          reduce using rule 54 (condition -> expression > expression .)
    )               reduce using rule 54 (condition -> expression > expression .)
    ,               reduce using rule 54 (condition -> expression > expression .)
    :               reduce using rule 54 (condition -> expression > expression .)
    +               shift and go to state 70
    -               shift and go to state 71


state 93

    (55) condition -> expression < expression .
    (60) expression -> expression . + term
    (61) expression -> expression . - term

    AND             reduce using rule 55 (condition -> expression < expression .)
    {               reduce using rule 55 (condition -> expression < expression .)
    OR              reduce using rule 55 (condition -> expression < expression .)
    VARIABLE        reduce using rule 55 (condition -> expression < expression .)
    ID              reduce using rule 55 (condition -> expression < expression .)
    WHILE           reduce using rule 55 (condition -> expression < expression .)
    FOR             reduce using rule 55 (condition -> expression < expression .)
    IF              reduce using rule 55 (condition -> expression < expression .)
    PRINT           reduce using rule 55 (condition -> expression < expression .)
    $end            reduce using rule 55 (condition -> expression < expression .)
    }               reduce using rule 55 (condition -> expression < expression .)
    RETURN          reduce using rule 55 (condition -> expression < expression .)
    )               reduce using rule 55 (condition -> expression < expression .)
    ,               reduce using rule 55 (condition -> expression < expression .)
    :               reduce using rule 55 (condition -> expression < expression .)
    +               shift and go to state 70
    -               shift and go to state 71


state 94

    (56) condition -> expression GTEQL expression .
    (60) expression -> expression . + term
    (61) expression -> expression . - term

    AND             reduce using rule 56 (condition -> expression GTEQL expression .)
    {               reduce using rule 56 (condition -> expression GTEQL expression .)
    OR              reduce using rule 56 (condition -> expression GTEQL expression .)
    VARIABLE        reduce using rule 56 (condition -> expression GTEQL expression .)
    ID              reduce using rule 56 (condition -> expression GTEQL expression .)
    WHILE           reduce using rule 56 (condition -> expression GTEQL expression .)
    FOR             reduce using rule 56 (condition -> expression GTEQL expression .)
    IF              reduce using rule 56 (condition -> expression GTEQL expression .)
    PRINT           reduce using rule 56 (condition -> expression GTEQL expression .)
    $end            reduce using rule 56 (condition -> expression GTEQL expression .)
    }               reduce using rule 56 (condition -> expression GTEQL expression .)
    RETURN          reduce using rule 56 (condition -> expression GTEQL expression .)
    )               reduce using rule 56 (condition -> expression GTEQL expression .)
    ,               reduce using rule 56 (condition -> expression GTEQL expression .)
    :               reduce using rule 56 (condition -> expression GTEQL expression .)
    +               shift and go to state 70
    -               shift and go to state 71


state 95

    (57) condition -> expression LTEQL expression .
    (60) expression -> expression . + term
    (61) expression -> expression . - term

    AND             reduce using rule 57 (condition -> expression LTEQL expression .)
    {               reduce using rule 57 (condition -> expression LTEQL expression .)
    OR              reduce using rule 57 (condition -> expression LTEQL expression .)
    VARIABLE        reduce using rule 57 (condition -> expression LTEQL expression .)
    ID              reduce using rule 57 (condition -> expression LTEQL expression .)
    WHILE           reduce using rule 57 (condition -> expression LTEQL expression .)
    FOR             reduce using rule 57 (condition -> expression LTEQL expression .)
    IF              reduce using rule 57 (condition -> expression LTEQL expression .)
    PRINT           reduce using rule 57 (condition -> expression LTEQL expression .)
    $end            reduce using rule 57 (condition -> expression LTEQL expression .)
    }               reduce using rule 57 (condition -> expression LTEQL expression .)
    RETURN          reduce using rule 57 (condition -> expression LTEQL expression .)
    )               reduce using rule 57 (condition -> expression LTEQL expression .)
    ,               reduce using rule 57 (condition -> expression LTEQL expression .)
    :               reduce using rule 57 (condition -> expression LTEQL expression .)
    +               shift and go to state 70
    -               shift and go to state 71


state 96

    (58) condition -> expression NOTEQL expression .
    (60) expression -> expression . + term
    (61) expression -> expression . - term

    AND             reduce using rule 58 (condition -> expression NOTEQL expression .)
    {               reduce using rule 58 (condition -> expression NOTEQL expression .)
    OR              reduce using rule 58 (condition -> expression NOTEQL expression .)
    VARIABLE        reduce using rule 58 (condition -> expression NOTEQL expression .)
    ID              reduce using rule 58 (condition -> expression NOTEQL expression .)
    WHILE           reduce using rule 58 (condition -> expression NOTEQL expression .)
    FOR             reduce using rule 58 (condition -> expression NOTEQL expression .)
    IF              reduce using rule 58 (condition -> expression NOTEQL expression .)
    PRINT           reduce using rule 58 (condition -> expression NOTEQL expression .)
    $end            reduce using rule 58 (condition -> expression NOTEQL expression .)
    }               reduce using rule 58 (condition -> expression NOTEQL expression .)
    RETURN          reduce using rule 58 (condition -> expression NOTEQL expression .)
    )               reduce using rule 58 (condition -> expression NOTEQL expression .)
    ,               reduce using rule 58 (condition -> expression NOTEQL expression .)
    :               reduce using rule 58 (condition -> expression NOTEQL expression .)
    +               shift and go to state 70
    -               shift and go to state 71


state 97

    (59) condition -> expression BOOLEQL expression .
    (60) expression -> expression . + term
    (61) expression -> expression . - term

    AND             reduce using rule 59 (condition -> expression BOOLEQL expression .)
    {               reduce using rule 59 (condition -> expression BOOLEQL expression .)
    OR              reduce using rule 59 (condition -> expression BOOLEQL expression .)
    VARIABLE        reduce using rule 59 (condition -> expression BOOLEQL expression .)
    ID              reduce using rule 59 (condition -> expression BOOLEQL expression .)
    WHILE           reduce using rule 59 (condition -> expression BOOLEQL expression .)
    FOR             reduce using rule 59 (condition -> expression BOOLEQL expression .)
    IF              reduce using rule 59 (condition -> expression BOOLEQL expression .)
    PRINT           reduce using rule 59 (condition -> expression BOOLEQL expression .)
    $end            reduce using rule 59 (condition -> expression BOOLEQL expression .)
    }               reduce using rule 59 (condition -> expression BOOLEQL expression .)
    RETURN          reduce using rule 59 (condition -> expression BOOLEQL expression .)
    )               reduce using rule 59 (condition -> expression BOOLEQL expression .)
    ,               reduce using rule 59 (condition -> expression BOOLEQL expression .)
    :               reduce using rule 59 (condition -> expression BOOLEQL expression .)
    +               shift and go to state 70
    -               shift and go to state 71


state 98

    (60) expression -> expression + term .
    (63) term -> term . * factor
    (64) term -> term . / factor

    >               reduce using rule 60 (expression -> expression + term .)
    <               reduce using rule 60 (expression -> expression + term .)
    GTEQL           reduce using rule 60 (expression -> expression + term .)
    LTEQL           reduce using rule 60 (expression -> expression + term .)
    NOTEQL          reduce using rule 60 (expression -> expression + term .)
    BOOLEQL         reduce using rule 60 (expression -> expression + term .)
    +               reduce using rule 60 (expression -> expression + term .)
    -               reduce using rule 60 (expression -> expression + term .)
    AND             reduce using rule 60 (expression -> expression + term .)
    {               reduce using rule 60 (expression -> expression + term .)
    OR              reduce using rule 60 (expression -> expression + term .)
    VARIABLE        reduce using rule 60 (expression -> expression + term .)
    ID              reduce using rule 60 (expression -> expression + term .)
    WHILE           reduce using rule 60 (expression -> expression + term .)
    FOR             reduce using rule 60 (expression -> expression + term .)
    IF              reduce using rule 60 (expression -> expression + term .)
    PRINT           reduce using rule 60 (expression -> expression + term .)
    $end            reduce using rule 60 (expression -> expression + term .)
    }               reduce using rule 60 (expression -> expression + term .)
    RETURN          reduce using rule 60 (expression -> expression + term .)
    )               reduce using rule 60 (expression -> expression + term .)
    ,               reduce using rule 60 (expression -> expression + term .)
    :               reduce using rule 60 (expression -> expression + term .)
    *               shift and go to state 72
    /               shift and go to state 73


state 99

    (61) expression -> expression - term .
    (63) term -> term . * factor
    (64) term -> term . / factor

    >               reduce using rule 61 (expression -> expression - term .)
    <               reduce using rule 61 (expression -> expression - term .)
    GTEQL           reduce using rule 61 (expression -> expression - term .)
    LTEQL           reduce using rule 61 (expression -> expression - term .)
    NOTEQL          reduce using rule 61 (expression -> expression - term .)
    BOOLEQL         reduce using rule 61 (expression -> expression - term .)
    +               reduce using rule 61 (expression -> expression - term .)
    -               reduce using rule 61 (expression -> expression - term .)
    AND             reduce using rule 61 (expression -> expression - term .)
    {               reduce using rule 61 (expression -> expression - term .)
    OR              reduce using rule 61 (expression -> expression - term .)
    VARIABLE        reduce using rule 61 (expression -> expression - term .)
    ID              reduce using rule 61 (expression -> expression - term .)
    WHILE           reduce using rule 61 (expression -> expression - term .)
    FOR             reduce using rule 61 (expression -> expression - term .)
    IF              reduce using rule 61 (expression -> expression - term .)
    PRINT           reduce using rule 61 (expression -> expression - term .)
    $end            reduce using rule 61 (expression -> expression - term .)
    }               reduce using rule 61 (expression -> expression - term .)
    RETURN          reduce using rule 61 (expression -> expression - term .)
    )               reduce using rule 61 (expression -> expression - term .)
    ,               reduce using rule 61 (expression -> expression - term .)
    :               reduce using rule 61 (expression -> expression - term .)
    *               shift and go to state 72
    /               shift and go to state 73


state 100

    (63) term -> term * factor .

    *               reduce using rule 63 (term -> term * factor .)
    /               reduce using rule 63 (term -> term * factor .)
    >               reduce using rule 63 (term -> term * factor .)
    <               reduce using rule 63 (term -> term * factor .)
    GTEQL           reduce using rule 63 (term -> term * factor .)
    LTEQL           reduce using rule 63 (term -> term * factor .)
    NOTEQL          reduce using rule 63 (term -> term * factor .)
    BOOLEQL         reduce using rule 63 (term -> term * factor .)
    +               reduce using rule 63 (term -> term * factor .)
    -               reduce using rule 63 (term -> term * factor .)
    AND             reduce using rule 63 (term -> term * factor .)
    {               reduce using rule 63 (term -> term * factor .)
    OR              reduce using rule 63 (term -> term * factor .)
    VARIABLE        reduce using rule 63 (term -> term * factor .)
    ID              reduce using rule 63 (term -> term * factor .)
    WHILE           reduce using rule 63 (term -> term * factor .)
    FOR             reduce using rule 63 (term -> term * factor .)
    IF              reduce using rule 63 (term -> term * factor .)
    PRINT           reduce using rule 63 (term -> term * factor .)
    $end            reduce using rule 63 (term -> term * factor .)
    }               reduce using rule 63 (term -> term * factor .)
    RETURN          reduce using rule 63 (term -> term * factor .)
    )               reduce using rule 63 (term -> term * factor .)
    ,               reduce using rule 63 (term -> term * factor .)
    :               reduce using rule 63 (term -> term * factor .)


state 101

    (64) term -> term / factor .

    *               reduce using rule 64 (term -> term / factor .)
    /               reduce using rule 64 (term -> term / factor .)
    >               reduce using rule 64 (term -> term / factor .)
    <               reduce using rule 64 (term -> term / factor .)
    GTEQL           reduce using rule 64 (term -> term / factor .)
    LTEQL           reduce using rule 64 (term -> term / factor .)
    NOTEQL          reduce using rule 64 (term -> term / factor .)
    BOOLEQL         reduce using rule 64 (term -> term / factor .)
    +               reduce using rule 64 (term -> term / factor .)
    -               reduce using rule 64 (term -> term / factor .)
    AND             reduce using rule 64 (term -> term / factor .)
    {               reduce using rule 64 (term -> term / factor .)
    OR              reduce using rule 64 (term -> term / factor .)
    VARIABLE        reduce using rule 64 (term -> term / factor .)
    ID              reduce using rule 64 (term -> term / factor .)
    WHILE           reduce using rule 64 (term -> term / factor .)
    FOR             reduce using rule 64 (term -> term / factor .)
    IF              reduce using rule 64 (term -> term / factor .)
    PRINT           reduce using rule 64 (term -> term / factor .)
    $end            reduce using rule 64 (term -> term / factor .)
    }               reduce using rule 64 (term -> term / factor .)
    RETURN          reduce using rule 64 (term -> term / factor .)
    )               reduce using rule 64 (term -> term / factor .)
    ,               reduce using rule 64 (term -> term / factor .)
    :               reduce using rule 64 (term -> term / factor .)


state 102

    (69) factor -> ( expression ) .

    *               reduce using rule 69 (factor -> ( expression ) .)
    /               reduce using rule 69 (factor -> ( expression ) .)
    >               reduce using rule 69 (factor -> ( expression ) .)
    <               reduce using rule 69 (factor -> ( expression ) .)
    GTEQL           reduce using rule 69 (factor -> ( expression ) .)
    LTEQL           reduce using rule 69 (factor -> ( expression ) .)
    NOTEQL          reduce using rule 69 (factor -> ( expression ) .)
    BOOLEQL         reduce using rule 69 (factor -> ( expression ) .)
    +               reduce using rule 69 (factor -> ( expression ) .)
    -               reduce using rule 69 (factor -> ( expression ) .)
    AND             reduce using rule 69 (factor -> ( expression ) .)
    {               reduce using rule 69 (factor -> ( expression ) .)
    OR              reduce using rule 69 (factor -> ( expression ) .)
    VARIABLE        reduce using rule 69 (factor -> ( expression ) .)
    ID              reduce using rule 69 (factor -> ( expression ) .)
    WHILE           reduce using rule 69 (factor -> ( expression ) .)
    FOR             reduce using rule 69 (factor -> ( expression ) .)
    IF              reduce using rule 69 (factor -> ( expression ) .)
    PRINT           reduce using rule 69 (factor -> ( expression ) .)
    $end            reduce using rule 69 (factor -> ( expression ) .)
    }               reduce using rule 69 (factor -> ( expression ) .)
    RETURN          reduce using rule 69 (factor -> ( expression ) .)
    )               reduce using rule 69 (factor -> ( expression ) .)
    ,               reduce using rule 69 (factor -> ( expression ) .)
    :               reduce using rule 69 (factor -> ( expression ) .)


state 103

    (71) ternary -> ( boolean ) . ? ( boolean : boolean )

    ?               shift and go to state 114


state 104

    (37) for -> FOR ( initialization , . boolean , assign ) { block }
    (38) for -> FOR ( initialization , . boolean , unary ) { block }
    (44) boolean -> . boolean OR boolterm
    (45) boolean -> . boolterm
    (46) boolterm -> . boolterm AND boolterm1
    (47) boolterm -> . boolterm1
    (48) boolterm1 -> . ! boolterm2
    (49) boolterm1 -> . boolterm2
    (50) boolterm2 -> . condition
    (51) boolterm2 -> . expression
    (52) boolterm2 -> . FALSE
    (53) boolterm2 -> . TRUE
    (54) condition -> . expression > expression
    (55) condition -> . expression < expression
    (56) condition -> . expression GTEQL expression
    (57) condition -> . expression LTEQL expression
    (58) condition -> . expression NOTEQL expression
    (59) condition -> . expression BOOLEQL expression
    (60) expression -> . expression + term
    (61) expression -> . expression - term
    (62) expression -> . term
    (63) term -> . term * factor
    (64) term -> . term / factor
    (65) term -> . factor
    (66) factor -> . ID
    (67) factor -> . NUMBER
    (68) factor -> . STRING
    (69) factor -> . ( expression )
    (70) factor -> . ternary
    (72) factor -> . funcall
    (71) ternary -> . ( boolean ) ? ( boolean : boolean )
    (28) funcall -> . ID ( paramlist )

    !               shift and go to state 36
    FALSE           shift and go to state 40
    TRUE            shift and go to state 41
    ID              shift and go to state 44
    NUMBER          shift and go to state 45
    STRING          shift and go to state 46
    (               shift and go to state 47

    boolean                        shift and go to state 115
    boolterm                       shift and go to state 34
    boolterm1                      shift and go to state 35
    boolterm2                      shift and go to state 37
    condition                      shift and go to state 38
    expression                     shift and go to state 39
    term                           shift and go to state 42
    factor                         shift and go to state 43
    ternary                        shift and go to state 48
    funcall                        shift and go to state 49

state 105

    (22) initialization -> VARIABLE ID . = boolean

    =               shift and go to state 55


state 106

    (39) for -> FOR ID IN RANGE . ( expression , expression ) { block }

    (               shift and go to state 116


state 107

    (32) if -> IF boolean { block . } elif

    }               shift and go to state 117


state 108

    (40) print -> PRINT ( plist ) .

    VARIABLE        reduce using rule 40 (print -> PRINT ( plist ) .)
    ID              reduce using rule 40 (print -> PRINT ( plist ) .)
    WHILE           reduce using rule 40 (print -> PRINT ( plist ) .)
    FOR             reduce using rule 40 (print -> PRINT ( plist ) .)
    IF              reduce using rule 40 (print -> PRINT ( plist ) .)
    PRINT           reduce using rule 40 (print -> PRINT ( plist ) .)
    $end            reduce using rule 40 (print -> PRINT ( plist ) .)
    }               reduce using rule 40 (print -> PRINT ( plist ) .)
    RETURN          reduce using rule 40 (print -> PRINT ( plist ) .)


state 109

    (41) plist -> pstat , . plist
    (41) plist -> . pstat , plist
    (42) plist -> . pstat
    (43) pstat -> . boolean
    (44) boolean -> . boolean OR boolterm
    (45) boolean -> . boolterm
    (46) boolterm -> . boolterm AND boolterm1
    (47) boolterm -> . boolterm1
    (48) boolterm1 -> . ! boolterm2
    (49) boolterm1 -> . boolterm2
    (50) boolterm2 -> . condition
    (51) boolterm2 -> . expression
    (52) boolterm2 -> . FALSE
    (53) boolterm2 -> . TRUE
    (54) condition -> . expression > expression
    (55) condition -> . expression < expression
    (56) condition -> . expression GTEQL expression
    (57) condition -> . expression LTEQL expression
    (58) condition -> . expression NOTEQL expression
    (59) condition -> . expression BOOLEQL expression
    (60) expression -> . expression + term
    (61) expression -> . expression - term
    (62) expression -> . term
    (63) term -> . term * factor
    (64) term -> . term / factor
    (65) term -> . factor
    (66) factor -> . ID
    (67) factor -> . NUMBER
    (68) factor -> . STRING
    (69) factor -> . ( expression )
    (70) factor -> . ternary
    (72) factor -> . funcall
    (71) ternary -> . ( boolean ) ? ( boolean : boolean )
    (28) funcall -> . ID ( paramlist )

    !               shift and go to state 36
    FALSE           shift and go to state 40
    TRUE            shift and go to state 41
    ID              shift and go to state 44
    NUMBER          shift and go to state 45
    STRING          shift and go to state 46
    (               shift and go to state 47

    pstat                          shift and go to state 81
    plist                          shift and go to state 118
    boolean                        shift and go to state 82
    boolterm                       shift and go to state 34
    boolterm1                      shift and go to state 35
    boolterm2                      shift and go to state 37
    condition                      shift and go to state 38
    expression                     shift and go to state 39
    term                           shift and go to state 42
    factor                         shift and go to state 43
    ternary                        shift and go to state 48
    funcall                        shift and go to state 49

state 110

    (6) argument -> ID , . argument
    (6) argument -> . ID , argument
    (7) argument -> . ID
    (8) argument -> . empty
    (9) empty -> .

    ID              shift and go to state 83
    )               reduce using rule 9 (empty -> .)

    argument                       shift and go to state 119
    empty                          shift and go to state 85

state 111

    (4) function -> FUNCTION ID ( argument ) . { block RETURN boolean }
    (5) function -> FUNCTION ID ( argument ) . { block RETURN }

    {               shift and go to state 120


state 112

    (29) paramlist -> boolean , paramlist .

    )               reduce using rule 29 (paramlist -> boolean , paramlist .)


state 113

    (36) while -> WHILE boolean { block } .

    VARIABLE        reduce using rule 36 (while -> WHILE boolean { block } .)
    ID              reduce using rule 36 (while -> WHILE boolean { block } .)
    WHILE           reduce using rule 36 (while -> WHILE boolean { block } .)
    FOR             reduce using rule 36 (while -> WHILE boolean { block } .)
    IF              reduce using rule 36 (while -> WHILE boolean { block } .)
    PRINT           reduce using rule 36 (while -> WHILE boolean { block } .)
    $end            reduce using rule 36 (while -> WHILE boolean { block } .)
    }               reduce using rule 36 (while -> WHILE boolean { block } .)
    RETURN          reduce using rule 36 (while -> WHILE boolean { block } .)


state 114

    (71) ternary -> ( boolean ) ? . ( boolean : boolean )

    (               shift and go to state 121


state 115

    (37) for -> FOR ( initialization , boolean . , assign ) { block }
    (38) for -> FOR ( initialization , boolean . , unary ) { block }
    (44) boolean -> boolean . OR boolterm

    ,               shift and go to state 122
    OR              shift and go to state 61


state 116

    (39) for -> FOR ID IN RANGE ( . expression , expression ) { block }
    (60) expression -> . expression + term
    (61) expression -> . expression - term
    (62) expression -> . term
    (63) term -> . term * factor
    (64) term -> . term / factor
    (65) term -> . factor
    (66) factor -> . ID
    (67) factor -> . NUMBER
    (68) factor -> . STRING
    (69) factor -> . ( expression )
    (70) factor -> . ternary
    (72) factor -> . funcall
    (71) ternary -> . ( boolean ) ? ( boolean : boolean )
    (28) funcall -> . ID ( paramlist )

    ID              shift and go to state 44
    NUMBER          shift and go to state 45
    STRING          shift and go to state 46
    (               shift and go to state 47

    expression                     shift and go to state 123
    term                           shift and go to state 42
    factor                         shift and go to state 43
    ternary                        shift and go to state 48
    funcall                        shift and go to state 49

state 117

    (32) if -> IF boolean { block } . elif
    (33) elif -> . ELSEIF boolean { block } elif
    (34) elif -> . ELSE { block }
    (35) elif -> . empty
    (9) empty -> .

    ELSEIF          shift and go to state 125
    ELSE            shift and go to state 126
    VARIABLE        reduce using rule 9 (empty -> .)
    ID              reduce using rule 9 (empty -> .)
    WHILE           reduce using rule 9 (empty -> .)
    FOR             reduce using rule 9 (empty -> .)
    IF              reduce using rule 9 (empty -> .)
    PRINT           reduce using rule 9 (empty -> .)
    $end            reduce using rule 9 (empty -> .)
    }               reduce using rule 9 (empty -> .)
    RETURN          reduce using rule 9 (empty -> .)

    elif                           shift and go to state 124
    empty                          shift and go to state 127

state 118

    (41) plist -> pstat , plist .

    )               reduce using rule 41 (plist -> pstat , plist .)


state 119

    (6) argument -> ID , argument .

    )               reduce using rule 6 (argument -> ID , argument .)


state 120

    (4) function -> FUNCTION ID ( argument ) { . block RETURN boolean }
    (5) function -> FUNCTION ID ( argument ) { . block RETURN }
    (10) block -> . statement block
    (11) block -> . statement
    (12) statement -> . declaration
    (13) statement -> . initialization
    (14) statement -> . assign
    (15) statement -> . funcall
    (16) statement -> . unary
    (17) statement -> . while
    (18) statement -> . for
    (19) statement -> . if
    (20) statement -> . print
    (21) declaration -> . VARIABLE ID
    (22) initialization -> . VARIABLE ID = boolean
    (23) assign -> . ID = boolean
    (28) funcall -> . ID ( paramlist )
    (24) unary -> . increment
    (25) unary -> . decrement
    (36) while -> . WHILE boolean { block }
    (37) for -> . FOR ( initialization , boolean , assign ) { block }
    (38) for -> . FOR ( initialization , boolean , unary ) { block }
    (39) for -> . FOR ID IN RANGE ( expression , expression ) { block }
    (32) if -> . IF boolean { block } elif
    (40) print -> . PRINT ( plist )
    (26) increment -> . ID INCRMNT
    (27) decrement -> . ID DECRMNT

    VARIABLE        shift and go to state 17
    ID              shift and go to state 18
    WHILE           shift and go to state 21
    FOR             shift and go to state 22
    IF              shift and go to state 23
    PRINT           shift and go to state 24

    block                          shift and go to state 128
    statement                      shift and go to state 7
    declaration                    shift and go to state 8
    initialization                 shift and go to state 9
    assign                         shift and go to state 10
    funcall                        shift and go to state 11
    unary                          shift and go to state 12
    while                          shift and go to state 13
    for                            shift and go to state 14
    if                             shift and go to state 15
    print                          shift and go to state 16
    increment                      shift and go to state 19
    decrement                      shift and go to state 20

state 121

    (71) ternary -> ( boolean ) ? ( . boolean : boolean )
    (44) boolean -> . boolean OR boolterm
    (45) boolean -> . boolterm
    (46) boolterm -> . boolterm AND boolterm1
    (47) boolterm -> . boolterm1
    (48) boolterm1 -> . ! boolterm2
    (49) boolterm1 -> . boolterm2
    (50) boolterm2 -> . condition
    (51) boolterm2 -> . expression
    (52) boolterm2 -> . FALSE
    (53) boolterm2 -> . TRUE
    (54) condition -> . expression > expression
    (55) condition -> . expression < expression
    (56) condition -> . expression GTEQL expression
    (57) condition -> . expression LTEQL expression
    (58) condition -> . expression NOTEQL expression
    (59) condition -> . expression BOOLEQL expression
    (60) expression -> . expression + term
    (61) expression -> . expression - term
    (62) expression -> . term
    (63) term -> . term * factor
    (64) term -> . term / factor
    (65) term -> . factor
    (66) factor -> . ID
    (67) factor -> . NUMBER
    (68) factor -> . STRING
    (69) factor -> . ( expression )
    (70) factor -> . ternary
    (72) factor -> . funcall
    (71) ternary -> . ( boolean ) ? ( boolean : boolean )
    (28) funcall -> . ID ( paramlist )

    !               shift and go to state 36
    FALSE           shift and go to state 40
    TRUE            shift and go to state 41
    ID              shift and go to state 44
    NUMBER          shift and go to state 45
    STRING          shift and go to state 46
    (               shift and go to state 47

    boolean                        shift and go to state 129
    boolterm                       shift and go to state 34
    boolterm1                      shift and go to state 35
    boolterm2                      shift and go to state 37
    condition                      shift and go to state 38
    expression                     shift and go to state 39
    term                           shift and go to state 42
    factor                         shift and go to state 43
    ternary                        shift and go to state 48
    funcall                        shift and go to state 49

state 122

    (37) for -> FOR ( initialization , boolean , . assign ) { block }
    (38) for -> FOR ( initialization , boolean , . unary ) { block }
    (23) assign -> . ID = boolean
    (24) unary -> . increment
    (25) unary -> . decrement
    (26) increment -> . ID INCRMNT
    (27) decrement -> . ID DECRMNT

    ID              shift and go to state 132

    assign                         shift and go to state 130
    unary                          shift and go to state 131
    increment                      shift and go to state 19
    decrement                      shift and go to state 20

state 123

    (39) for -> FOR ID IN RANGE ( expression . , expression ) { block }
    (60) expression -> expression . + term
    (61) expression -> expression . - term

    ,               shift and go to state 133
    +               shift and go to state 70
    -               shift and go to state 71


state 124

    (32) if -> IF boolean { block } elif .

    VARIABLE        reduce using rule 32 (if -> IF boolean { block } elif .)
    ID              reduce using rule 32 (if -> IF boolean { block } elif .)
    WHILE           reduce using rule 32 (if -> IF boolean { block } elif .)
    FOR             reduce using rule 32 (if -> IF boolean { block } elif .)
    IF              reduce using rule 32 (if -> IF boolean { block } elif .)
    PRINT           reduce using rule 32 (if -> IF boolean { block } elif .)
    $end            reduce using rule 32 (if -> IF boolean { block } elif .)
    }               reduce using rule 32 (if -> IF boolean { block } elif .)
    RETURN          reduce using rule 32 (if -> IF boolean { block } elif .)


state 125

    (33) elif -> ELSEIF . boolean { block } elif
    (44) boolean -> . boolean OR boolterm
    (45) boolean -> . boolterm
    (46) boolterm -> . boolterm AND boolterm1
    (47) boolterm -> . boolterm1
    (48) boolterm1 -> . ! boolterm2
    (49) boolterm1 -> . boolterm2
    (50) boolterm2 -> . condition
    (51) boolterm2 -> . expression
    (52) boolterm2 -> . FALSE
    (53) boolterm2 -> . TRUE
    (54) condition -> . expression > expression
    (55) condition -> . expression < expression
    (56) condition -> . expression GTEQL expression
    (57) condition -> . expression LTEQL expression
    (58) condition -> . expression NOTEQL expression
    (59) condition -> . expression BOOLEQL expression
    (60) expression -> . expression + term
    (61) expression -> . expression - term
    (62) expression -> . term
    (63) term -> . term * factor
    (64) term -> . term / factor
    (65) term -> . factor
    (66) factor -> . ID
    (67) factor -> . NUMBER
    (68) factor -> . STRING
    (69) factor -> . ( expression )
    (70) factor -> . ternary
    (72) factor -> . funcall
    (71) ternary -> . ( boolean ) ? ( boolean : boolean )
    (28) funcall -> . ID ( paramlist )

    !               shift and go to state 36
    FALSE           shift and go to state 40
    TRUE            shift and go to state 41
    ID              shift and go to state 44
    NUMBER          shift and go to state 45
    STRING          shift and go to state 46
    (               shift and go to state 47

    boolean                        shift and go to state 134
    boolterm                       shift and go to state 34
    boolterm1                      shift and go to state 35
    boolterm2                      shift and go to state 37
    condition                      shift and go to state 38
    expression                     shift and go to state 39
    term                           shift and go to state 42
    factor                         shift and go to state 43
    ternary                        shift and go to state 48
    funcall                        shift and go to state 49

state 126

    (34) elif -> ELSE . { block }

    {               shift and go to state 135


state 127

    (35) elif -> empty .

    VARIABLE        reduce using rule 35 (elif -> empty .)
    ID              reduce using rule 35 (elif -> empty .)
    WHILE           reduce using rule 35 (elif -> empty .)
    FOR             reduce using rule 35 (elif -> empty .)
    IF              reduce using rule 35 (elif -> empty .)
    PRINT           reduce using rule 35 (elif -> empty .)
    $end            reduce using rule 35 (elif -> empty .)
    }               reduce using rule 35 (elif -> empty .)
    RETURN          reduce using rule 35 (elif -> empty .)


state 128

    (4) function -> FUNCTION ID ( argument ) { block . RETURN boolean }
    (5) function -> FUNCTION ID ( argument ) { block . RETURN }

    RETURN          shift and go to state 136


state 129

    (71) ternary -> ( boolean ) ? ( boolean . : boolean )
    (44) boolean -> boolean . OR boolterm

    :               shift and go to state 137
    OR              shift and go to state 61


state 130

    (37) for -> FOR ( initialization , boolean , assign . ) { block }

    )               shift and go to state 138


state 131

    (38) for -> FOR ( initialization , boolean , unary . ) { block }

    )               shift and go to state 139


state 132

    (23) assign -> ID . = boolean
    (26) increment -> ID . INCRMNT
    (27) decrement -> ID . DECRMNT

    =               shift and go to state 29
    INCRMNT         shift and go to state 31
    DECRMNT         shift and go to state 32


state 133

    (39) for -> FOR ID IN RANGE ( expression , . expression ) { block }
    (60) expression -> . expression + term
    (61) expression -> . expression - term
    (62) expression -> . term
    (63) term -> . term * factor
    (64) term -> . term / factor
    (65) term -> . factor
    (66) factor -> . ID
    (67) factor -> . NUMBER
    (68) factor -> . STRING
    (69) factor -> . ( expression )
    (70) factor -> . ternary
    (72) factor -> . funcall
    (71) ternary -> . ( boolean ) ? ( boolean : boolean )
    (28) funcall -> . ID ( paramlist )

    ID              shift and go to state 44
    NUMBER          shift and go to state 45
    STRING          shift and go to state 46
    (               shift and go to state 47

    expression                     shift and go to state 140
    term                           shift and go to state 42
    factor                         shift and go to state 43
    ternary                        shift and go to state 48
    funcall                        shift and go to state 49

state 134

    (33) elif -> ELSEIF boolean . { block } elif
    (44) boolean -> boolean . OR boolterm

    {               shift and go to state 141
    OR              shift and go to state 61


state 135

    (34) elif -> ELSE { . block }
    (10) block -> . statement block
    (11) block -> . statement
    (12) statement -> . declaration
    (13) statement -> . initialization
    (14) statement -> . assign
    (15) statement -> . funcall
    (16) statement -> . unary
    (17) statement -> . while
    (18) statement -> . for
    (19) statement -> . if
    (20) statement -> . print
    (21) declaration -> . VARIABLE ID
    (22) initialization -> . VARIABLE ID = boolean
    (23) assign -> . ID = boolean
    (28) funcall -> . ID ( paramlist )
    (24) unary -> . increment
    (25) unary -> . decrement
    (36) while -> . WHILE boolean { block }
    (37) for -> . FOR ( initialization , boolean , assign ) { block }
    (38) for -> . FOR ( initialization , boolean , unary ) { block }
    (39) for -> . FOR ID IN RANGE ( expression , expression ) { block }
    (32) if -> . IF boolean { block } elif
    (40) print -> . PRINT ( plist )
    (26) increment -> . ID INCRMNT
    (27) decrement -> . ID DECRMNT

    VARIABLE        shift and go to state 17
    ID              shift and go to state 18
    WHILE           shift and go to state 21
    FOR             shift and go to state 22
    IF              shift and go to state 23
    PRINT           shift and go to state 24

    block                          shift and go to state 142
    statement                      shift and go to state 7
    declaration                    shift and go to state 8
    initialization                 shift and go to state 9
    assign                         shift and go to state 10
    funcall                        shift and go to state 11
    unary                          shift and go to state 12
    while                          shift and go to state 13
    for                            shift and go to state 14
    if                             shift and go to state 15
    print                          shift and go to state 16
    increment                      shift and go to state 19
    decrement                      shift and go to state 20

state 136

    (4) function -> FUNCTION ID ( argument ) { block RETURN . boolean }
    (5) function -> FUNCTION ID ( argument ) { block RETURN . }
    (44) boolean -> . boolean OR boolterm
    (45) boolean -> . boolterm
    (46) boolterm -> . boolterm AND boolterm1
    (47) boolterm -> . boolterm1
    (48) boolterm1 -> . ! boolterm2
    (49) boolterm1 -> . boolterm2
    (50) boolterm2 -> . condition
    (51) boolterm2 -> . expression
    (52) boolterm2 -> . FALSE
    (53) boolterm2 -> . TRUE
    (54) condition -> . expression > expression
    (55) condition -> . expression < expression
    (56) condition -> . expression GTEQL expression
    (57) condition -> . expression LTEQL expression
    (58) condition -> . expression NOTEQL expression
    (59) condition -> . expression BOOLEQL expression
    (60) expression -> . expression + term
    (61) expression -> . expression - term
    (62) expression -> . term
    (63) term -> . term * factor
    (64) term -> . term / factor
    (65) term -> . factor
    (66) factor -> . ID
    (67) factor -> . NUMBER
    (68) factor -> . STRING
    (69) factor -> . ( expression )
    (70) factor -> . ternary
    (72) factor -> . funcall
    (71) ternary -> . ( boolean ) ? ( boolean : boolean )
    (28) funcall -> . ID ( paramlist )

    }               shift and go to state 144
    !               shift and go to state 36
    FALSE           shift and go to state 40
    TRUE            shift and go to state 41
    ID              shift and go to state 44
    NUMBER          shift and go to state 45
    STRING          shift and go to state 46
    (               shift and go to state 47

    boolean                        shift and go to state 143
    boolterm                       shift and go to state 34
    boolterm1                      shift and go to state 35
    boolterm2                      shift and go to state 37
    condition                      shift and go to state 38
    expression                     shift and go to state 39
    term                           shift and go to state 42
    factor                         shift and go to state 43
    ternary                        shift and go to state 48
    funcall                        shift and go to state 49

state 137

    (71) ternary -> ( boolean ) ? ( boolean : . boolean )
    (44) boolean -> . boolean OR boolterm
    (45) boolean -> . boolterm
    (46) boolterm -> . boolterm AND boolterm1
    (47) boolterm -> . boolterm1
    (48) boolterm1 -> . ! boolterm2
    (49) boolterm1 -> . boolterm2
    (50) boolterm2 -> . condition
    (51) boolterm2 -> . expression
    (52) boolterm2 -> . FALSE
    (53) boolterm2 -> . TRUE
    (54) condition -> . expression > expression
    (55) condition -> . expression < expression
    (56) condition -> . expression GTEQL expression
    (57) condition -> . expression LTEQL expression
    (58) condition -> . expression NOTEQL expression
    (59) condition -> . expression BOOLEQL expression
    (60) expression -> . expression + term
    (61) expression -> . expression - term
    (62) expression -> . term
    (63) term -> . term * factor
    (64) term -> . term / factor
    (65) term -> . factor
    (66) factor -> . ID
    (67) factor -> . NUMBER
    (68) factor -> . STRING
    (69) factor -> . ( expression )
    (70) factor -> . ternary
    (72) factor -> . funcall
    (71) ternary -> . ( boolean ) ? ( boolean : boolean )
    (28) funcall -> . ID ( paramlist )

    !               shift and go to state 36
    FALSE           shift and go to state 40
    TRUE            shift and go to state 41
    ID              shift and go to state 44
    NUMBER          shift and go to state 45
    STRING          shift and go to state 46
    (               shift and go to state 47

    boolean                        shift and go to state 145
    boolterm                       shift and go to state 34
    boolterm1                      shift and go to state 35
    boolterm2                      shift and go to state 37
    condition                      shift and go to state 38
    expression                     shift and go to state 39
    term                           shift and go to state 42
    factor                         shift and go to state 43
    ternary                        shift and go to state 48
    funcall                        shift and go to state 49

state 138

    (37) for -> FOR ( initialization , boolean , assign ) . { block }

    {               shift and go to state 146


state 139

    (38) for -> FOR ( initialization , boolean , unary ) . { block }

    {               shift and go to state 147


state 140

    (39) for -> FOR ID IN RANGE ( expression , expression . ) { block }
    (60) expression -> expression . + term
    (61) expression -> expression . - term

    )               shift and go to state 148
    +               shift and go to state 70
    -               shift and go to state 71


state 141

    (33) elif -> ELSEIF boolean { . block } elif
    (10) block -> . statement block
    (11) block -> . statement
    (12) statement -> . declaration
    (13) statement -> . initialization
    (14) statement -> . assign
    (15) statement -> . funcall
    (16) statement -> . unary
    (17) statement -> . while
    (18) statement -> . for
    (19) statement -> . if
    (20) statement -> . print
    (21) declaration -> . VARIABLE ID
    (22) initialization -> . VARIABLE ID = boolean
    (23) assign -> . ID = boolean
    (28) funcall -> . ID ( paramlist )
    (24) unary -> . increment
    (25) unary -> . decrement
    (36) while -> . WHILE boolean { block }
    (37) for -> . FOR ( initialization , boolean , assign ) { block }
    (38) for -> . FOR ( initialization , boolean , unary ) { block }
    (39) for -> . FOR ID IN RANGE ( expression , expression ) { block }
    (32) if -> . IF boolean { block } elif
    (40) print -> . PRINT ( plist )
    (26) increment -> . ID INCRMNT
    (27) decrement -> . ID DECRMNT

    VARIABLE        shift and go to state 17
    ID              shift and go to state 18
    WHILE           shift and go to state 21
    FOR             shift and go to state 22
    IF              shift and go to state 23
    PRINT           shift and go to state 24

    block                          shift and go to state 149
    statement                      shift and go to state 7
    declaration                    shift and go to state 8
    initialization                 shift and go to state 9
    assign                         shift and go to state 10
    funcall                        shift and go to state 11
    unary                          shift and go to state 12
    while                          shift and go to state 13
    for                            shift and go to state 14
    if                             shift and go to state 15
    print                          shift and go to state 16
    increment                      shift and go to state 19
    decrement                      shift and go to state 20

state 142

    (34) elif -> ELSE { block . }

    }               shift and go to state 150


state 143

    (4) function -> FUNCTION ID ( argument ) { block RETURN boolean . }
    (44) boolean -> boolean . OR boolterm

    }               shift and go to state 151
    OR              shift and go to state 61


state 144

    (5) function -> FUNCTION ID ( argument ) { block RETURN } .

    FUNCTION        reduce using rule 5 (function -> FUNCTION ID ( argument ) { block RETURN } .)
    VARIABLE        reduce using rule 5 (function -> FUNCTION ID ( argument ) { block RETURN } .)
    ID              reduce using rule 5 (function -> FUNCTION ID ( argument ) { block RETURN } .)
    WHILE           reduce using rule 5 (function -> FUNCTION ID ( argument ) { block RETURN } .)
    FOR             reduce using rule 5 (function -> FUNCTION ID ( argument ) { block RETURN } .)
    IF              reduce using rule 5 (function -> FUNCTION ID ( argument ) { block RETURN } .)
    PRINT           reduce using rule 5 (function -> FUNCTION ID ( argument ) { block RETURN } .)


state 145

    (71) ternary -> ( boolean ) ? ( boolean : boolean . )
    (44) boolean -> boolean . OR boolterm

    )               shift and go to state 152
    OR              shift and go to state 61


state 146

    (37) for -> FOR ( initialization , boolean , assign ) { . block }
    (10) block -> . statement block
    (11) block -> . statement
    (12) statement -> . declaration
    (13) statement -> . initialization
    (14) statement -> . assign
    (15) statement -> . funcall
    (16) statement -> . unary
    (17) statement -> . while
    (18) statement -> . for
    (19) statement -> . if
    (20) statement -> . print
    (21) declaration -> . VARIABLE ID
    (22) initialization -> . VARIABLE ID = boolean
    (23) assign -> . ID = boolean
    (28) funcall -> . ID ( paramlist )
    (24) unary -> . increment
    (25) unary -> . decrement
    (36) while -> . WHILE boolean { block }
    (37) for -> . FOR ( initialization , boolean , assign ) { block }
    (38) for -> . FOR ( initialization , boolean , unary ) { block }
    (39) for -> . FOR ID IN RANGE ( expression , expression ) { block }
    (32) if -> . IF boolean { block } elif
    (40) print -> . PRINT ( plist )
    (26) increment -> . ID INCRMNT
    (27) decrement -> . ID DECRMNT

    VARIABLE        shift and go to state 17
    ID              shift and go to state 18
    WHILE           shift and go to state 21
    FOR             shift and go to state 22
    IF              shift and go to state 23
    PRINT           shift and go to state 24

    initialization                 shift and go to state 9
    assign                         shift and go to state 10
    block                          shift and go to state 153
    statement                      shift and go to state 7
    declaration                    shift and go to state 8
    funcall                        shift and go to state 11
    unary                          shift and go to state 12
    while                          shift and go to state 13
    for                            shift and go to state 14
    if                             shift and go to state 15
    print                          shift and go to state 16
    increment                      shift and go to state 19
    decrement                      shift and go to state 20

state 147

    (38) for -> FOR ( initialization , boolean , unary ) { . block }
    (10) block -> . statement block
    (11) block -> . statement
    (12) statement -> . declaration
    (13) statement -> . initialization
    (14) statement -> . assign
    (15) statement -> . funcall
    (16) statement -> . unary
    (17) statement -> . while
    (18) statement -> . for
    (19) statement -> . if
    (20) statement -> . print
    (21) declaration -> . VARIABLE ID
    (22) initialization -> . VARIABLE ID = boolean
    (23) assign -> . ID = boolean
    (28) funcall -> . ID ( paramlist )
    (24) unary -> . increment
    (25) unary -> . decrement
    (36) while -> . WHILE boolean { block }
    (37) for -> . FOR ( initialization , boolean , assign ) { block }
    (38) for -> . FOR ( initialization , boolean , unary ) { block }
    (39) for -> . FOR ID IN RANGE ( expression , expression ) { block }
    (32) if -> . IF boolean { block } elif
    (40) print -> . PRINT ( plist )
    (26) increment -> . ID INCRMNT
    (27) decrement -> . ID DECRMNT

    VARIABLE        shift and go to state 17
    ID              shift and go to state 18
    WHILE           shift and go to state 21
    FOR             shift and go to state 22
    IF              shift and go to state 23
    PRINT           shift and go to state 24

    initialization                 shift and go to state 9
    unary                          shift and go to state 12
    block                          shift and go to state 154
    statement                      shift and go to state 7
    declaration                    shift and go to state 8
    assign                         shift and go to state 10
    funcall                        shift and go to state 11
    while                          shift and go to state 13
    for                            shift and go to state 14
    if                             shift and go to state 15
    print                          shift and go to state 16
    increment                      shift and go to state 19
    decrement                      shift and go to state 20

state 148

    (39) for -> FOR ID IN RANGE ( expression , expression ) . { block }

    {               shift and go to state 155


state 149

    (33) elif -> ELSEIF boolean { block . } elif

    }               shift and go to state 156


state 150

    (34) elif -> ELSE { block } .

    VARIABLE        reduce using rule 34 (elif -> ELSE { block } .)
    ID              reduce using rule 34 (elif -> ELSE { block } .)
    WHILE           reduce using rule 34 (elif -> ELSE { block } .)
    FOR             reduce using rule 34 (elif -> ELSE { block } .)
    IF              reduce using rule 34 (elif -> ELSE { block } .)
    PRINT           reduce using rule 34 (elif -> ELSE { block } .)
    $end            reduce using rule 34 (elif -> ELSE { block } .)
    }               reduce using rule 34 (elif -> ELSE { block } .)
    RETURN          reduce using rule 34 (elif -> ELSE { block } .)


state 151

    (4) function -> FUNCTION ID ( argument ) { block RETURN boolean } .

    FUNCTION        reduce using rule 4 (function -> FUNCTION ID ( argument ) { block RETURN boolean } .)
    VARIABLE        reduce using rule 4 (function -> FUNCTION ID ( argument ) { block RETURN boolean } .)
    ID              reduce using rule 4 (function -> FUNCTION ID ( argument ) { block RETURN boolean } .)
    WHILE           reduce using rule 4 (function -> FUNCTION ID ( argument ) { block RETURN boolean } .)
    FOR             reduce using rule 4 (function -> FUNCTION ID ( argument ) { block RETURN boolean } .)
    IF              reduce using rule 4 (function -> FUNCTION ID ( argument ) { block RETURN boolean } .)
    PRINT           reduce using rule 4 (function -> FUNCTION ID ( argument ) { block RETURN boolean } .)


state 152

    (71) ternary -> ( boolean ) ? ( boolean : boolean ) .

    *               reduce using rule 71 (ternary -> ( boolean ) ? ( boolean : boolean ) .)
    /               reduce using rule 71 (ternary -> ( boolean ) ? ( boolean : boolean ) .)
    >               reduce using rule 71 (ternary -> ( boolean ) ? ( boolean : boolean ) .)
    <               reduce using rule 71 (ternary -> ( boolean ) ? ( boolean : boolean ) .)
    GTEQL           reduce using rule 71 (ternary -> ( boolean ) ? ( boolean : boolean ) .)
    LTEQL           reduce using rule 71 (ternary -> ( boolean ) ? ( boolean : boolean ) .)
    NOTEQL          reduce using rule 71 (ternary -> ( boolean ) ? ( boolean : boolean ) .)
    BOOLEQL         reduce using rule 71 (ternary -> ( boolean ) ? ( boolean : boolean ) .)
    +               reduce using rule 71 (ternary -> ( boolean ) ? ( boolean : boolean ) .)
    -               reduce using rule 71 (ternary -> ( boolean ) ? ( boolean : boolean ) .)
    AND             reduce using rule 71 (ternary -> ( boolean ) ? ( boolean : boolean ) .)
    {               reduce using rule 71 (ternary -> ( boolean ) ? ( boolean : boolean ) .)
    OR              reduce using rule 71 (ternary -> ( boolean ) ? ( boolean : boolean ) .)
    VARIABLE        reduce using rule 71 (ternary -> ( boolean ) ? ( boolean : boolean ) .)
    ID              reduce using rule 71 (ternary -> ( boolean ) ? ( boolean : boolean ) .)
    WHILE           reduce using rule 71 (ternary -> ( boolean ) ? ( boolean : boolean ) .)
    FOR             reduce using rule 71 (ternary -> ( boolean ) ? ( boolean : boolean ) .)
    IF              reduce using rule 71 (ternary -> ( boolean ) ? ( boolean : boolean ) .)
    PRINT           reduce using rule 71 (ternary -> ( boolean ) ? ( boolean : boolean ) .)
    $end            reduce using rule 71 (ternary -> ( boolean ) ? ( boolean : boolean ) .)
    }               reduce using rule 71 (ternary -> ( boolean ) ? ( boolean : boolean ) .)
    RETURN          reduce using rule 71 (ternary -> ( boolean ) ? ( boolean : boolean ) .)
    )               reduce using rule 71 (ternary -> ( boolean ) ? ( boolean : boolean ) .)
    ,               reduce using rule 71 (ternary -> ( boolean ) ? ( boolean : boolean ) .)
    :               reduce using rule 71 (ternary -> ( boolean ) ? ( boolean : boolean ) .)


state 153

    (37) for -> FOR ( initialization , boolean , assign ) { block . }

    }               shift and go to state 157


state 154

    (38) for -> FOR ( initialization , boolean , unary ) { block . }

    }               shift and go to state 158


state 155

    (39) for -> FOR ID IN RANGE ( expression , expression ) { . block }
    (10) block -> . statement block
    (11) block -> . statement
    (12) statement -> . declaration
    (13) statement -> . initialization
    (14) statement -> . assign
    (15) statement -> . funcall
    (16) statement -> . unary
    (17) statement -> . while
    (18) statement -> . for
    (19) statement -> . if
    (20) statement -> . print
    (21) declaration -> . VARIABLE ID
    (22) initialization -> . VARIABLE ID = boolean
    (23) assign -> . ID = boolean
    (28) funcall -> . ID ( paramlist )
    (24) unary -> . increment
    (25) unary -> . decrement
    (36) while -> . WHILE boolean { block }
    (37) for -> . FOR ( initialization , boolean , assign ) { block }
    (38) for -> . FOR ( initialization , boolean , unary ) { block }
    (39) for -> . FOR ID IN RANGE ( expression , expression ) { block }
    (32) if -> . IF boolean { block } elif
    (40) print -> . PRINT ( plist )
    (26) increment -> . ID INCRMNT
    (27) decrement -> . ID DECRMNT

    VARIABLE        shift and go to state 17
    ID              shift and go to state 18
    WHILE           shift and go to state 21
    FOR             shift and go to state 22
    IF              shift and go to state 23
    PRINT           shift and go to state 24

    block                          shift and go to state 159
    statement                      shift and go to state 7
    declaration                    shift and go to state 8
    initialization                 shift and go to state 9
    assign                         shift and go to state 10
    funcall                        shift and go to state 11
    unary                          shift and go to state 12
    while                          shift and go to state 13
    for                            shift and go to state 14
    if                             shift and go to state 15
    print                          shift and go to state 16
    increment                      shift and go to state 19
    decrement                      shift and go to state 20

state 156

    (33) elif -> ELSEIF boolean { block } . elif
    (33) elif -> . ELSEIF boolean { block } elif
    (34) elif -> . ELSE { block }
    (35) elif -> . empty
    (9) empty -> .

    ELSEIF          shift and go to state 125
    ELSE            shift and go to state 126
    VARIABLE        reduce using rule 9 (empty -> .)
    ID              reduce using rule 9 (empty -> .)
    WHILE           reduce using rule 9 (empty -> .)
    FOR             reduce using rule 9 (empty -> .)
    IF              reduce using rule 9 (empty -> .)
    PRINT           reduce using rule 9 (empty -> .)
    $end            reduce using rule 9 (empty -> .)
    }               reduce using rule 9 (empty -> .)
    RETURN          reduce using rule 9 (empty -> .)

    elif                           shift and go to state 160
    empty                          shift and go to state 127

state 157

    (37) for -> FOR ( initialization , boolean , assign ) { block } .

    VARIABLE        reduce using rule 37 (for -> FOR ( initialization , boolean , assign ) { block } .)
    ID              reduce using rule 37 (for -> FOR ( initialization , boolean , assign ) { block } .)
    WHILE           reduce using rule 37 (for -> FOR ( initialization , boolean , assign ) { block } .)
    FOR             reduce using rule 37 (for -> FOR ( initialization , boolean , assign ) { block } .)
    IF              reduce using rule 37 (for -> FOR ( initialization , boolean , assign ) { block } .)
    PRINT           reduce using rule 37 (for -> FOR ( initialization , boolean , assign ) { block } .)
    $end            reduce using rule 37 (for -> FOR ( initialization , boolean , assign ) { block } .)
    }               reduce using rule 37 (for -> FOR ( initialization , boolean , assign ) { block } .)
    RETURN          reduce using rule 37 (for -> FOR ( initialization , boolean , assign ) { block } .)


state 158

    (38) for -> FOR ( initialization , boolean , unary ) { block } .

    VARIABLE        reduce using rule 38 (for -> FOR ( initialization , boolean , unary ) { block } .)
    ID              reduce using rule 38 (for -> FOR ( initialization , boolean , unary ) { block } .)
    WHILE           reduce using rule 38 (for -> FOR ( initialization , boolean , unary ) { block } .)
    FOR             reduce using rule 38 (for -> FOR ( initialization , boolean , unary ) { block } .)
    IF              reduce using rule 38 (for -> FOR ( initialization , boolean , unary ) { block } .)
    PRINT           reduce using rule 38 (for -> FOR ( initialization , boolean , unary ) { block } .)
    $end            reduce using rule 38 (for -> FOR ( initialization , boolean , unary ) { block } .)
    }               reduce using rule 38 (for -> FOR ( initialization , boolean , unary ) { block } .)
    RETURN          reduce using rule 38 (for -> FOR ( initialization , boolean , unary ) { block } .)


state 159

    (39) for -> FOR ID IN RANGE ( expression , expression ) { block . }

    }               shift and go to state 161


state 160

    (33) elif -> ELSEIF boolean { block } elif .

    VARIABLE        reduce using rule 33 (elif -> ELSEIF boolean { block } elif .)
    ID              reduce using rule 33 (elif -> ELSEIF boolean { block } elif .)
    WHILE           reduce using rule 33 (elif -> ELSEIF boolean { block } elif .)
    FOR             reduce using rule 33 (elif -> ELSEIF boolean { block } elif .)
    IF              reduce using rule 33 (elif -> ELSEIF boolean { block } elif .)
    PRINT           reduce using rule 33 (elif -> ELSEIF boolean { block } elif .)
    $end            reduce using rule 33 (elif -> ELSEIF boolean { block } elif .)
    }               reduce using rule 33 (elif -> ELSEIF boolean { block } elif .)
    RETURN          reduce using rule 33 (elif -> ELSEIF boolean { block } elif .)


state 161

    (39) for -> FOR ID IN RANGE ( expression , expression ) { block } .

    VARIABLE        reduce using rule 39 (for -> FOR ID IN RANGE ( expression , expression ) { block } .)
    ID              reduce using rule 39 (for -> FOR ID IN RANGE ( expression , expression ) { block } .)
    WHILE           reduce using rule 39 (for -> FOR ID IN RANGE ( expression , expression ) { block } .)
    FOR             reduce using rule 39 (for -> FOR ID IN RANGE ( expression , expression ) { block } .)
    IF              reduce using rule 39 (for -> FOR ID IN RANGE ( expression , expression ) { block } .)
    PRINT           reduce using rule 39 (for -> FOR ID IN RANGE ( expression , expression ) { block } .)
    $end            reduce using rule 39 (for -> FOR ID IN RANGE ( expression , expression ) { block } .)
    }               reduce using rule 39 (for -> FOR ID IN RANGE ( expression , expression ) { block } .)
    RETURN          reduce using rule 39 (for -> FOR ID IN RANGE ( expression , expression ) { block } .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for ) in state 74 resolved as shift
