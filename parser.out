Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> program
Rule 1     program -> functionlist block
Rule 2     functionlist -> function functionlist
Rule 3     functionlist -> empty
Rule 4     function -> FUNCTION ID ( argument ) { block RETURN boolean }
Rule 5     function -> FUNCTION ID ( argument ) { block RETURN }
Rule 6     argument -> ID , argument
Rule 7     argument -> ID
Rule 8     argument -> empty
Rule 9     empty -> <empty>
Rule 10    block -> statement block
Rule 11    block -> statement
Rule 12    statement -> declaration
Rule 13    statement -> initialization
Rule 14    statement -> assign
Rule 15    statement -> funcall
Rule 16    statement -> unary
Rule 17    statement -> while
Rule 18    statement -> for
Rule 19    statement -> if
Rule 20    statement -> print
Rule 21    declaration -> VARIABLE ID
Rule 22    initialization -> VARIABLE ID = STRING
Rule 23    initialization -> VARIABLE ID = boolean
Rule 24    assign -> ID = STRING
Rule 25    assign -> ID = boolean
Rule 26    assign -> ID = funcall
Rule 27    unary -> increment
Rule 28    unary -> decrement
Rule 29    increment -> ID INCRMNT
Rule 30    decrement -> ID DECRMNT
Rule 31    funcall -> ID ( argument )
Rule 32    if -> IF boolean { block } elif
Rule 33    elif -> ELSEIF boolean { block } elif
Rule 34    elif -> ELSE { block }
Rule 35    elif -> empty
Rule 36    while -> WHILE boolean { block }
Rule 37    for -> FOR ( initialization ; boolean ; assign ) { block }
Rule 38    for -> FOR ( initialization ; boolean ; unary ) { block }
Rule 39    for -> FOR ID IN RANGE ( expression , expression ) { block }
Rule 40    print -> PRINT ( plist )
Rule 41    plist -> pstat , plist
Rule 42    plist -> pstat
Rule 43    pstat -> STRING
Rule 44    pstat -> boolean
Rule 45    boolean -> boolean OR boolterm
Rule 46    boolean -> boolterm
Rule 47    boolterm -> boolterm AND boolterm1
Rule 48    boolterm -> boolterm1
Rule 49    boolterm1 -> NOT boolterm2
Rule 50    boolterm1 -> boolterm2
Rule 51    boolterm2 -> condition
Rule 52    boolterm2 -> expression
Rule 53    boolterm2 -> FALSE
Rule 54    boolterm2 -> TRUE
Rule 55    condition -> expression < expression
Rule 56    condition -> expression > expression
Rule 57    condition -> expression GTEQL expression
Rule 58    condition -> expression LTEQL expression
Rule 59    condition -> expression NOTEQL expression
Rule 60    condition -> expression BOOLEQL expression
Rule 61    expression -> expression + term
Rule 62    expression -> expression - term
Rule 63    expression -> term
Rule 64    term -> term * factor
Rule 65    term -> term / factor
Rule 66    term -> factor
Rule 67    factor -> ID
Rule 68    factor -> NUMBER
Rule 69    factor -> ( expression )

Terminals, with rules where they appear

(                    : 4 5 31 37 38 39 40 69
)                    : 4 5 31 37 38 39 40 69
*                    : 64
+                    : 61
,                    : 6 39 41
-                    : 62
/                    : 65
;                    : 37 37 38 38
<                    : 55
=                    : 22 23 24 25 26
>                    : 56
AND                  : 47
BOOLEQL              : 60
DECRMNT              : 30
ELSE                 : 34
ELSEIF               : 33
FALSE                : 53
FOR                  : 37 38 39
FUNCTION             : 4 5
GTEQL                : 57
ID                   : 4 5 6 7 21 22 23 24 25 26 29 30 31 39 67
IF                   : 32
IN                   : 39
INCRMNT              : 29
LTEQL                : 58
NOT                  : 49
NOTEQL               : 59
NUMBER               : 68
OR                   : 45
PRINT                : 40
RANGE                : 39
RETURN               : 4 5
STRING               : 22 24 43
TRUE                 : 54
VARIABLE             : 21 22 23
WHILE                : 36
error                : 
{                    : 4 5 32 33 34 36 37 38 39
}                    : 4 5 32 33 34 36 37 38 39

Nonterminals, with rules where they appear

argument             : 4 5 6 31
assign               : 14 37
block                : 1 4 5 10 32 33 34 36 37 38 39
boolean              : 4 23 25 32 33 36 37 38 44 45
boolterm             : 45 46 47
boolterm1            : 47 48
boolterm2            : 49 50
condition            : 51
declaration          : 12
decrement            : 28
elif                 : 32 33
empty                : 3 8 35
expression           : 39 39 52 55 55 56 56 57 57 58 58 59 59 60 60 61 62 69
factor               : 64 65 66
for                  : 18
funcall              : 15 26
function             : 2
functionlist         : 1 2
if                   : 19
increment            : 27
initialization       : 13 37 38
plist                : 40 41
print                : 20
program              : 0
pstat                : 41 42
statement            : 10 11
term                 : 61 62 63 64 65
unary                : 16 38
while                : 17

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . functionlist block
    (2) functionlist -> . function functionlist
    (3) functionlist -> . empty
    (4) function -> . FUNCTION ID ( argument ) { block RETURN boolean }
    (5) function -> . FUNCTION ID ( argument ) { block RETURN }
    (9) empty -> .

    FUNCTION        shift and go to state 5
    VARIABLE        reduce using rule 9 (empty -> .)
    ID              reduce using rule 9 (empty -> .)
    WHILE           reduce using rule 9 (empty -> .)
    FOR             reduce using rule 9 (empty -> .)
    IF              reduce using rule 9 (empty -> .)
    PRINT           reduce using rule 9 (empty -> .)

    program                        shift and go to state 1
    functionlist                   shift and go to state 2
    function                       shift and go to state 3
    empty                          shift and go to state 4

state 1

    (0) S' -> program .



state 2

    (1) program -> functionlist . block
    (10) block -> . statement block
    (11) block -> . statement
    (12) statement -> . declaration
    (13) statement -> . initialization
    (14) statement -> . assign
    (15) statement -> . funcall
    (16) statement -> . unary
    (17) statement -> . while
    (18) statement -> . for
    (19) statement -> . if
    (20) statement -> . print
    (21) declaration -> . VARIABLE ID
    (22) initialization -> . VARIABLE ID = STRING
    (23) initialization -> . VARIABLE ID = boolean
    (24) assign -> . ID = STRING
    (25) assign -> . ID = boolean
    (26) assign -> . ID = funcall
    (31) funcall -> . ID ( argument )
    (27) unary -> . increment
    (28) unary -> . decrement
    (36) while -> . WHILE boolean { block }
    (37) for -> . FOR ( initialization ; boolean ; assign ) { block }
    (38) for -> . FOR ( initialization ; boolean ; unary ) { block }
    (39) for -> . FOR ID IN RANGE ( expression , expression ) { block }
    (32) if -> . IF boolean { block } elif
    (40) print -> . PRINT ( plist )
    (29) increment -> . ID INCRMNT
    (30) decrement -> . ID DECRMNT

    VARIABLE        shift and go to state 17
    ID              shift and go to state 18
    WHILE           shift and go to state 21
    FOR             shift and go to state 22
    IF              shift and go to state 23
    PRINT           shift and go to state 24

    block                          shift and go to state 6
    statement                      shift and go to state 7
    declaration                    shift and go to state 8
    initialization                 shift and go to state 9
    assign                         shift and go to state 10
    funcall                        shift and go to state 11
    unary                          shift and go to state 12
    while                          shift and go to state 13
    for                            shift and go to state 14
    if                             shift and go to state 15
    print                          shift and go to state 16
    increment                      shift and go to state 19
    decrement                      shift and go to state 20

state 3

    (2) functionlist -> function . functionlist
    (2) functionlist -> . function functionlist
    (3) functionlist -> . empty
    (4) function -> . FUNCTION ID ( argument ) { block RETURN boolean }
    (5) function -> . FUNCTION ID ( argument ) { block RETURN }
    (9) empty -> .

    FUNCTION        shift and go to state 5
    VARIABLE        reduce using rule 9 (empty -> .)
    ID              reduce using rule 9 (empty -> .)
    WHILE           reduce using rule 9 (empty -> .)
    FOR             reduce using rule 9 (empty -> .)
    IF              reduce using rule 9 (empty -> .)
    PRINT           reduce using rule 9 (empty -> .)

    function                       shift and go to state 3
    functionlist                   shift and go to state 25
    empty                          shift and go to state 4

state 4

    (3) functionlist -> empty .

    VARIABLE        reduce using rule 3 (functionlist -> empty .)
    ID              reduce using rule 3 (functionlist -> empty .)
    WHILE           reduce using rule 3 (functionlist -> empty .)
    FOR             reduce using rule 3 (functionlist -> empty .)
    IF              reduce using rule 3 (functionlist -> empty .)
    PRINT           reduce using rule 3 (functionlist -> empty .)


state 5

    (4) function -> FUNCTION . ID ( argument ) { block RETURN boolean }
    (5) function -> FUNCTION . ID ( argument ) { block RETURN }

    ID              shift and go to state 26


state 6

    (1) program -> functionlist block .

    $end            reduce using rule 1 (program -> functionlist block .)


state 7

    (10) block -> statement . block
    (11) block -> statement .
    (10) block -> . statement block
    (11) block -> . statement
    (12) statement -> . declaration
    (13) statement -> . initialization
    (14) statement -> . assign
    (15) statement -> . funcall
    (16) statement -> . unary
    (17) statement -> . while
    (18) statement -> . for
    (19) statement -> . if
    (20) statement -> . print
    (21) declaration -> . VARIABLE ID
    (22) initialization -> . VARIABLE ID = STRING
    (23) initialization -> . VARIABLE ID = boolean
    (24) assign -> . ID = STRING
    (25) assign -> . ID = boolean
    (26) assign -> . ID = funcall
    (31) funcall -> . ID ( argument )
    (27) unary -> . increment
    (28) unary -> . decrement
    (36) while -> . WHILE boolean { block }
    (37) for -> . FOR ( initialization ; boolean ; assign ) { block }
    (38) for -> . FOR ( initialization ; boolean ; unary ) { block }
    (39) for -> . FOR ID IN RANGE ( expression , expression ) { block }
    (32) if -> . IF boolean { block } elif
    (40) print -> . PRINT ( plist )
    (29) increment -> . ID INCRMNT
    (30) decrement -> . ID DECRMNT

    $end            reduce using rule 11 (block -> statement .)
    }               reduce using rule 11 (block -> statement .)
    RETURN          reduce using rule 11 (block -> statement .)
    VARIABLE        shift and go to state 17
    ID              shift and go to state 18
    WHILE           shift and go to state 21
    FOR             shift and go to state 22
    IF              shift and go to state 23
    PRINT           shift and go to state 24

    statement                      shift and go to state 7
    block                          shift and go to state 27
    declaration                    shift and go to state 8
    initialization                 shift and go to state 9
    assign                         shift and go to state 10
    funcall                        shift and go to state 11
    unary                          shift and go to state 12
    while                          shift and go to state 13
    for                            shift and go to state 14
    if                             shift and go to state 15
    print                          shift and go to state 16
    increment                      shift and go to state 19
    decrement                      shift and go to state 20

state 8

    (12) statement -> declaration .

    VARIABLE        reduce using rule 12 (statement -> declaration .)
    ID              reduce using rule 12 (statement -> declaration .)
    WHILE           reduce using rule 12 (statement -> declaration .)
    FOR             reduce using rule 12 (statement -> declaration .)
    IF              reduce using rule 12 (statement -> declaration .)
    PRINT           reduce using rule 12 (statement -> declaration .)
    $end            reduce using rule 12 (statement -> declaration .)
    }               reduce using rule 12 (statement -> declaration .)
    RETURN          reduce using rule 12 (statement -> declaration .)


state 9

    (13) statement -> initialization .

    VARIABLE        reduce using rule 13 (statement -> initialization .)
    ID              reduce using rule 13 (statement -> initialization .)
    WHILE           reduce using rule 13 (statement -> initialization .)
    FOR             reduce using rule 13 (statement -> initialization .)
    IF              reduce using rule 13 (statement -> initialization .)
    PRINT           reduce using rule 13 (statement -> initialization .)
    $end            reduce using rule 13 (statement -> initialization .)
    }               reduce using rule 13 (statement -> initialization .)
    RETURN          reduce using rule 13 (statement -> initialization .)


state 10

    (14) statement -> assign .

    VARIABLE        reduce using rule 14 (statement -> assign .)
    ID              reduce using rule 14 (statement -> assign .)
    WHILE           reduce using rule 14 (statement -> assign .)
    FOR             reduce using rule 14 (statement -> assign .)
    IF              reduce using rule 14 (statement -> assign .)
    PRINT           reduce using rule 14 (statement -> assign .)
    $end            reduce using rule 14 (statement -> assign .)
    }               reduce using rule 14 (statement -> assign .)
    RETURN          reduce using rule 14 (statement -> assign .)


state 11

    (15) statement -> funcall .

    VARIABLE        reduce using rule 15 (statement -> funcall .)
    ID              reduce using rule 15 (statement -> funcall .)
    WHILE           reduce using rule 15 (statement -> funcall .)
    FOR             reduce using rule 15 (statement -> funcall .)
    IF              reduce using rule 15 (statement -> funcall .)
    PRINT           reduce using rule 15 (statement -> funcall .)
    $end            reduce using rule 15 (statement -> funcall .)
    }               reduce using rule 15 (statement -> funcall .)
    RETURN          reduce using rule 15 (statement -> funcall .)


state 12

    (16) statement -> unary .

    VARIABLE        reduce using rule 16 (statement -> unary .)
    ID              reduce using rule 16 (statement -> unary .)
    WHILE           reduce using rule 16 (statement -> unary .)
    FOR             reduce using rule 16 (statement -> unary .)
    IF              reduce using rule 16 (statement -> unary .)
    PRINT           reduce using rule 16 (statement -> unary .)
    $end            reduce using rule 16 (statement -> unary .)
    }               reduce using rule 16 (statement -> unary .)
    RETURN          reduce using rule 16 (statement -> unary .)


state 13

    (17) statement -> while .

    VARIABLE        reduce using rule 17 (statement -> while .)
    ID              reduce using rule 17 (statement -> while .)
    WHILE           reduce using rule 17 (statement -> while .)
    FOR             reduce using rule 17 (statement -> while .)
    IF              reduce using rule 17 (statement -> while .)
    PRINT           reduce using rule 17 (statement -> while .)
    $end            reduce using rule 17 (statement -> while .)
    }               reduce using rule 17 (statement -> while .)
    RETURN          reduce using rule 17 (statement -> while .)


state 14

    (18) statement -> for .

    VARIABLE        reduce using rule 18 (statement -> for .)
    ID              reduce using rule 18 (statement -> for .)
    WHILE           reduce using rule 18 (statement -> for .)
    FOR             reduce using rule 18 (statement -> for .)
    IF              reduce using rule 18 (statement -> for .)
    PRINT           reduce using rule 18 (statement -> for .)
    $end            reduce using rule 18 (statement -> for .)
    }               reduce using rule 18 (statement -> for .)
    RETURN          reduce using rule 18 (statement -> for .)


state 15

    (19) statement -> if .

    VARIABLE        reduce using rule 19 (statement -> if .)
    ID              reduce using rule 19 (statement -> if .)
    WHILE           reduce using rule 19 (statement -> if .)
    FOR             reduce using rule 19 (statement -> if .)
    IF              reduce using rule 19 (statement -> if .)
    PRINT           reduce using rule 19 (statement -> if .)
    $end            reduce using rule 19 (statement -> if .)
    }               reduce using rule 19 (statement -> if .)
    RETURN          reduce using rule 19 (statement -> if .)


state 16

    (20) statement -> print .

    VARIABLE        reduce using rule 20 (statement -> print .)
    ID              reduce using rule 20 (statement -> print .)
    WHILE           reduce using rule 20 (statement -> print .)
    FOR             reduce using rule 20 (statement -> print .)
    IF              reduce using rule 20 (statement -> print .)
    PRINT           reduce using rule 20 (statement -> print .)
    $end            reduce using rule 20 (statement -> print .)
    }               reduce using rule 20 (statement -> print .)
    RETURN          reduce using rule 20 (statement -> print .)


state 17

    (21) declaration -> VARIABLE . ID
    (22) initialization -> VARIABLE . ID = STRING
    (23) initialization -> VARIABLE . ID = boolean

    ID              shift and go to state 28


state 18

    (24) assign -> ID . = STRING
    (25) assign -> ID . = boolean
    (26) assign -> ID . = funcall
    (31) funcall -> ID . ( argument )
    (29) increment -> ID . INCRMNT
    (30) decrement -> ID . DECRMNT

    =               shift and go to state 29
    (               shift and go to state 30
    INCRMNT         shift and go to state 31
    DECRMNT         shift and go to state 32


state 19

    (27) unary -> increment .

    VARIABLE        reduce using rule 27 (unary -> increment .)
    ID              reduce using rule 27 (unary -> increment .)
    WHILE           reduce using rule 27 (unary -> increment .)
    FOR             reduce using rule 27 (unary -> increment .)
    IF              reduce using rule 27 (unary -> increment .)
    PRINT           reduce using rule 27 (unary -> increment .)
    $end            reduce using rule 27 (unary -> increment .)
    }               reduce using rule 27 (unary -> increment .)
    RETURN          reduce using rule 27 (unary -> increment .)
    )               reduce using rule 27 (unary -> increment .)


state 20

    (28) unary -> decrement .

    VARIABLE        reduce using rule 28 (unary -> decrement .)
    ID              reduce using rule 28 (unary -> decrement .)
    WHILE           reduce using rule 28 (unary -> decrement .)
    FOR             reduce using rule 28 (unary -> decrement .)
    IF              reduce using rule 28 (unary -> decrement .)
    PRINT           reduce using rule 28 (unary -> decrement .)
    $end            reduce using rule 28 (unary -> decrement .)
    }               reduce using rule 28 (unary -> decrement .)
    RETURN          reduce using rule 28 (unary -> decrement .)
    )               reduce using rule 28 (unary -> decrement .)


state 21

    (36) while -> WHILE . boolean { block }
    (45) boolean -> . boolean OR boolterm
    (46) boolean -> . boolterm
    (47) boolterm -> . boolterm AND boolterm1
    (48) boolterm -> . boolterm1
    (49) boolterm1 -> . NOT boolterm2
    (50) boolterm1 -> . boolterm2
    (51) boolterm2 -> . condition
    (52) boolterm2 -> . expression
    (53) boolterm2 -> . FALSE
    (54) boolterm2 -> . TRUE
    (55) condition -> . expression < expression
    (56) condition -> . expression > expression
    (57) condition -> . expression GTEQL expression
    (58) condition -> . expression LTEQL expression
    (59) condition -> . expression NOTEQL expression
    (60) condition -> . expression BOOLEQL expression
    (61) expression -> . expression + term
    (62) expression -> . expression - term
    (63) expression -> . term
    (64) term -> . term * factor
    (65) term -> . term / factor
    (66) term -> . factor
    (67) factor -> . ID
    (68) factor -> . NUMBER
    (69) factor -> . ( expression )

    NOT             shift and go to state 36
    FALSE           shift and go to state 40
    TRUE            shift and go to state 41
    ID              shift and go to state 44
    NUMBER          shift and go to state 45
    (               shift and go to state 46

    boolean                        shift and go to state 33
    boolterm                       shift and go to state 34
    boolterm1                      shift and go to state 35
    boolterm2                      shift and go to state 37
    condition                      shift and go to state 38
    expression                     shift and go to state 39
    term                           shift and go to state 42
    factor                         shift and go to state 43

state 22

    (37) for -> FOR . ( initialization ; boolean ; assign ) { block }
    (38) for -> FOR . ( initialization ; boolean ; unary ) { block }
    (39) for -> FOR . ID IN RANGE ( expression , expression ) { block }

    (               shift and go to state 47
    ID              shift and go to state 48


state 23

    (32) if -> IF . boolean { block } elif
    (45) boolean -> . boolean OR boolterm
    (46) boolean -> . boolterm
    (47) boolterm -> . boolterm AND boolterm1
    (48) boolterm -> . boolterm1
    (49) boolterm1 -> . NOT boolterm2
    (50) boolterm1 -> . boolterm2
    (51) boolterm2 -> . condition
    (52) boolterm2 -> . expression
    (53) boolterm2 -> . FALSE
    (54) boolterm2 -> . TRUE
    (55) condition -> . expression < expression
    (56) condition -> . expression > expression
    (57) condition -> . expression GTEQL expression
    (58) condition -> . expression LTEQL expression
    (59) condition -> . expression NOTEQL expression
    (60) condition -> . expression BOOLEQL expression
    (61) expression -> . expression + term
    (62) expression -> . expression - term
    (63) expression -> . term
    (64) term -> . term * factor
    (65) term -> . term / factor
    (66) term -> . factor
    (67) factor -> . ID
    (68) factor -> . NUMBER
    (69) factor -> . ( expression )

    NOT             shift and go to state 36
    FALSE           shift and go to state 40
    TRUE            shift and go to state 41
    ID              shift and go to state 44
    NUMBER          shift and go to state 45
    (               shift and go to state 46

    boolean                        shift and go to state 49
    boolterm                       shift and go to state 34
    boolterm1                      shift and go to state 35
    boolterm2                      shift and go to state 37
    condition                      shift and go to state 38
    expression                     shift and go to state 39
    term                           shift and go to state 42
    factor                         shift and go to state 43

state 24

    (40) print -> PRINT . ( plist )

    (               shift and go to state 50


state 25

    (2) functionlist -> function functionlist .

    VARIABLE        reduce using rule 2 (functionlist -> function functionlist .)
    ID              reduce using rule 2 (functionlist -> function functionlist .)
    WHILE           reduce using rule 2 (functionlist -> function functionlist .)
    FOR             reduce using rule 2 (functionlist -> function functionlist .)
    IF              reduce using rule 2 (functionlist -> function functionlist .)
    PRINT           reduce using rule 2 (functionlist -> function functionlist .)


state 26

    (4) function -> FUNCTION ID . ( argument ) { block RETURN boolean }
    (5) function -> FUNCTION ID . ( argument ) { block RETURN }

    (               shift and go to state 51


state 27

    (10) block -> statement block .

    $end            reduce using rule 10 (block -> statement block .)
    }               reduce using rule 10 (block -> statement block .)
    RETURN          reduce using rule 10 (block -> statement block .)


state 28

    (21) declaration -> VARIABLE ID .
    (22) initialization -> VARIABLE ID . = STRING
    (23) initialization -> VARIABLE ID . = boolean

    VARIABLE        reduce using rule 21 (declaration -> VARIABLE ID .)
    ID              reduce using rule 21 (declaration -> VARIABLE ID .)
    WHILE           reduce using rule 21 (declaration -> VARIABLE ID .)
    FOR             reduce using rule 21 (declaration -> VARIABLE ID .)
    IF              reduce using rule 21 (declaration -> VARIABLE ID .)
    PRINT           reduce using rule 21 (declaration -> VARIABLE ID .)
    $end            reduce using rule 21 (declaration -> VARIABLE ID .)
    }               reduce using rule 21 (declaration -> VARIABLE ID .)
    RETURN          reduce using rule 21 (declaration -> VARIABLE ID .)
    =               shift and go to state 52


state 29

    (24) assign -> ID = . STRING
    (25) assign -> ID = . boolean
    (26) assign -> ID = . funcall
    (45) boolean -> . boolean OR boolterm
    (46) boolean -> . boolterm
    (31) funcall -> . ID ( argument )
    (47) boolterm -> . boolterm AND boolterm1
    (48) boolterm -> . boolterm1
    (49) boolterm1 -> . NOT boolterm2
    (50) boolterm1 -> . boolterm2
    (51) boolterm2 -> . condition
    (52) boolterm2 -> . expression
    (53) boolterm2 -> . FALSE
    (54) boolterm2 -> . TRUE
    (55) condition -> . expression < expression
    (56) condition -> . expression > expression
    (57) condition -> . expression GTEQL expression
    (58) condition -> . expression LTEQL expression
    (59) condition -> . expression NOTEQL expression
    (60) condition -> . expression BOOLEQL expression
    (61) expression -> . expression + term
    (62) expression -> . expression - term
    (63) expression -> . term
    (64) term -> . term * factor
    (65) term -> . term / factor
    (66) term -> . factor
    (67) factor -> . ID
    (68) factor -> . NUMBER
    (69) factor -> . ( expression )

    STRING          shift and go to state 54
    ID              shift and go to state 53
    NOT             shift and go to state 36
    FALSE           shift and go to state 40
    TRUE            shift and go to state 41
    NUMBER          shift and go to state 45
    (               shift and go to state 46

    boolean                        shift and go to state 55
    funcall                        shift and go to state 56
    boolterm                       shift and go to state 34
    boolterm1                      shift and go to state 35
    boolterm2                      shift and go to state 37
    condition                      shift and go to state 38
    expression                     shift and go to state 39
    term                           shift and go to state 42
    factor                         shift and go to state 43

state 30

    (31) funcall -> ID ( . argument )
    (6) argument -> . ID , argument
    (7) argument -> . ID
    (8) argument -> . empty
    (9) empty -> .

    ID              shift and go to state 57
    )               reduce using rule 9 (empty -> .)

    argument                       shift and go to state 58
    empty                          shift and go to state 59

state 31

    (29) increment -> ID INCRMNT .

    VARIABLE        reduce using rule 29 (increment -> ID INCRMNT .)
    ID              reduce using rule 29 (increment -> ID INCRMNT .)
    WHILE           reduce using rule 29 (increment -> ID INCRMNT .)
    FOR             reduce using rule 29 (increment -> ID INCRMNT .)
    IF              reduce using rule 29 (increment -> ID INCRMNT .)
    PRINT           reduce using rule 29 (increment -> ID INCRMNT .)
    $end            reduce using rule 29 (increment -> ID INCRMNT .)
    }               reduce using rule 29 (increment -> ID INCRMNT .)
    RETURN          reduce using rule 29 (increment -> ID INCRMNT .)
    )               reduce using rule 29 (increment -> ID INCRMNT .)


state 32

    (30) decrement -> ID DECRMNT .

    VARIABLE        reduce using rule 30 (decrement -> ID DECRMNT .)
    ID              reduce using rule 30 (decrement -> ID DECRMNT .)
    WHILE           reduce using rule 30 (decrement -> ID DECRMNT .)
    FOR             reduce using rule 30 (decrement -> ID DECRMNT .)
    IF              reduce using rule 30 (decrement -> ID DECRMNT .)
    PRINT           reduce using rule 30 (decrement -> ID DECRMNT .)
    $end            reduce using rule 30 (decrement -> ID DECRMNT .)
    }               reduce using rule 30 (decrement -> ID DECRMNT .)
    RETURN          reduce using rule 30 (decrement -> ID DECRMNT .)
    )               reduce using rule 30 (decrement -> ID DECRMNT .)


state 33

    (36) while -> WHILE boolean . { block }
    (45) boolean -> boolean . OR boolterm

    {               shift and go to state 60
    OR              shift and go to state 61


state 34

    (46) boolean -> boolterm .
    (47) boolterm -> boolterm . AND boolterm1

    {               reduce using rule 46 (boolean -> boolterm .)
    OR              reduce using rule 46 (boolean -> boolterm .)
    VARIABLE        reduce using rule 46 (boolean -> boolterm .)
    ID              reduce using rule 46 (boolean -> boolterm .)
    WHILE           reduce using rule 46 (boolean -> boolterm .)
    FOR             reduce using rule 46 (boolean -> boolterm .)
    IF              reduce using rule 46 (boolean -> boolterm .)
    PRINT           reduce using rule 46 (boolean -> boolterm .)
    $end            reduce using rule 46 (boolean -> boolterm .)
    }               reduce using rule 46 (boolean -> boolterm .)
    RETURN          reduce using rule 46 (boolean -> boolterm .)
    )               reduce using rule 46 (boolean -> boolterm .)
    ,               reduce using rule 46 (boolean -> boolterm .)
    ;               reduce using rule 46 (boolean -> boolterm .)
    AND             shift and go to state 62


state 35

    (48) boolterm -> boolterm1 .

    AND             reduce using rule 48 (boolterm -> boolterm1 .)
    {               reduce using rule 48 (boolterm -> boolterm1 .)
    OR              reduce using rule 48 (boolterm -> boolterm1 .)
    VARIABLE        reduce using rule 48 (boolterm -> boolterm1 .)
    ID              reduce using rule 48 (boolterm -> boolterm1 .)
    WHILE           reduce using rule 48 (boolterm -> boolterm1 .)
    FOR             reduce using rule 48 (boolterm -> boolterm1 .)
    IF              reduce using rule 48 (boolterm -> boolterm1 .)
    PRINT           reduce using rule 48 (boolterm -> boolterm1 .)
    $end            reduce using rule 48 (boolterm -> boolterm1 .)
    }               reduce using rule 48 (boolterm -> boolterm1 .)
    RETURN          reduce using rule 48 (boolterm -> boolterm1 .)
    )               reduce using rule 48 (boolterm -> boolterm1 .)
    ,               reduce using rule 48 (boolterm -> boolterm1 .)
    ;               reduce using rule 48 (boolterm -> boolterm1 .)


state 36

    (49) boolterm1 -> NOT . boolterm2
    (51) boolterm2 -> . condition
    (52) boolterm2 -> . expression
    (53) boolterm2 -> . FALSE
    (54) boolterm2 -> . TRUE
    (55) condition -> . expression < expression
    (56) condition -> . expression > expression
    (57) condition -> . expression GTEQL expression
    (58) condition -> . expression LTEQL expression
    (59) condition -> . expression NOTEQL expression
    (60) condition -> . expression BOOLEQL expression
    (61) expression -> . expression + term
    (62) expression -> . expression - term
    (63) expression -> . term
    (64) term -> . term * factor
    (65) term -> . term / factor
    (66) term -> . factor
    (67) factor -> . ID
    (68) factor -> . NUMBER
    (69) factor -> . ( expression )

    FALSE           shift and go to state 40
    TRUE            shift and go to state 41
    ID              shift and go to state 44
    NUMBER          shift and go to state 45
    (               shift and go to state 46

    boolterm2                      shift and go to state 63
    condition                      shift and go to state 38
    expression                     shift and go to state 39
    term                           shift and go to state 42
    factor                         shift and go to state 43

state 37

    (50) boolterm1 -> boolterm2 .

    AND             reduce using rule 50 (boolterm1 -> boolterm2 .)
    {               reduce using rule 50 (boolterm1 -> boolterm2 .)
    OR              reduce using rule 50 (boolterm1 -> boolterm2 .)
    VARIABLE        reduce using rule 50 (boolterm1 -> boolterm2 .)
    ID              reduce using rule 50 (boolterm1 -> boolterm2 .)
    WHILE           reduce using rule 50 (boolterm1 -> boolterm2 .)
    FOR             reduce using rule 50 (boolterm1 -> boolterm2 .)
    IF              reduce using rule 50 (boolterm1 -> boolterm2 .)
    PRINT           reduce using rule 50 (boolterm1 -> boolterm2 .)
    $end            reduce using rule 50 (boolterm1 -> boolterm2 .)
    }               reduce using rule 50 (boolterm1 -> boolterm2 .)
    RETURN          reduce using rule 50 (boolterm1 -> boolterm2 .)
    )               reduce using rule 50 (boolterm1 -> boolterm2 .)
    ,               reduce using rule 50 (boolterm1 -> boolterm2 .)
    ;               reduce using rule 50 (boolterm1 -> boolterm2 .)


state 38

    (51) boolterm2 -> condition .

    AND             reduce using rule 51 (boolterm2 -> condition .)
    {               reduce using rule 51 (boolterm2 -> condition .)
    OR              reduce using rule 51 (boolterm2 -> condition .)
    VARIABLE        reduce using rule 51 (boolterm2 -> condition .)
    ID              reduce using rule 51 (boolterm2 -> condition .)
    WHILE           reduce using rule 51 (boolterm2 -> condition .)
    FOR             reduce using rule 51 (boolterm2 -> condition .)
    IF              reduce using rule 51 (boolterm2 -> condition .)
    PRINT           reduce using rule 51 (boolterm2 -> condition .)
    $end            reduce using rule 51 (boolterm2 -> condition .)
    }               reduce using rule 51 (boolterm2 -> condition .)
    RETURN          reduce using rule 51 (boolterm2 -> condition .)
    )               reduce using rule 51 (boolterm2 -> condition .)
    ,               reduce using rule 51 (boolterm2 -> condition .)
    ;               reduce using rule 51 (boolterm2 -> condition .)


state 39

    (52) boolterm2 -> expression .
    (55) condition -> expression . < expression
    (56) condition -> expression . > expression
    (57) condition -> expression . GTEQL expression
    (58) condition -> expression . LTEQL expression
    (59) condition -> expression . NOTEQL expression
    (60) condition -> expression . BOOLEQL expression
    (61) expression -> expression . + term
    (62) expression -> expression . - term

    AND             reduce using rule 52 (boolterm2 -> expression .)
    {               reduce using rule 52 (boolterm2 -> expression .)
    OR              reduce using rule 52 (boolterm2 -> expression .)
    VARIABLE        reduce using rule 52 (boolterm2 -> expression .)
    ID              reduce using rule 52 (boolterm2 -> expression .)
    WHILE           reduce using rule 52 (boolterm2 -> expression .)
    FOR             reduce using rule 52 (boolterm2 -> expression .)
    IF              reduce using rule 52 (boolterm2 -> expression .)
    PRINT           reduce using rule 52 (boolterm2 -> expression .)
    $end            reduce using rule 52 (boolterm2 -> expression .)
    }               reduce using rule 52 (boolterm2 -> expression .)
    RETURN          reduce using rule 52 (boolterm2 -> expression .)
    )               reduce using rule 52 (boolterm2 -> expression .)
    ,               reduce using rule 52 (boolterm2 -> expression .)
    ;               reduce using rule 52 (boolterm2 -> expression .)
    <               shift and go to state 64
    >               shift and go to state 65
    GTEQL           shift and go to state 66
    LTEQL           shift and go to state 67
    NOTEQL          shift and go to state 68
    BOOLEQL         shift and go to state 69
    +               shift and go to state 70
    -               shift and go to state 71


state 40

    (53) boolterm2 -> FALSE .

    AND             reduce using rule 53 (boolterm2 -> FALSE .)
    {               reduce using rule 53 (boolterm2 -> FALSE .)
    OR              reduce using rule 53 (boolterm2 -> FALSE .)
    VARIABLE        reduce using rule 53 (boolterm2 -> FALSE .)
    ID              reduce using rule 53 (boolterm2 -> FALSE .)
    WHILE           reduce using rule 53 (boolterm2 -> FALSE .)
    FOR             reduce using rule 53 (boolterm2 -> FALSE .)
    IF              reduce using rule 53 (boolterm2 -> FALSE .)
    PRINT           reduce using rule 53 (boolterm2 -> FALSE .)
    $end            reduce using rule 53 (boolterm2 -> FALSE .)
    }               reduce using rule 53 (boolterm2 -> FALSE .)
    RETURN          reduce using rule 53 (boolterm2 -> FALSE .)
    )               reduce using rule 53 (boolterm2 -> FALSE .)
    ,               reduce using rule 53 (boolterm2 -> FALSE .)
    ;               reduce using rule 53 (boolterm2 -> FALSE .)


state 41

    (54) boolterm2 -> TRUE .

    AND             reduce using rule 54 (boolterm2 -> TRUE .)
    {               reduce using rule 54 (boolterm2 -> TRUE .)
    OR              reduce using rule 54 (boolterm2 -> TRUE .)
    VARIABLE        reduce using rule 54 (boolterm2 -> TRUE .)
    ID              reduce using rule 54 (boolterm2 -> TRUE .)
    WHILE           reduce using rule 54 (boolterm2 -> TRUE .)
    FOR             reduce using rule 54 (boolterm2 -> TRUE .)
    IF              reduce using rule 54 (boolterm2 -> TRUE .)
    PRINT           reduce using rule 54 (boolterm2 -> TRUE .)
    $end            reduce using rule 54 (boolterm2 -> TRUE .)
    }               reduce using rule 54 (boolterm2 -> TRUE .)
    RETURN          reduce using rule 54 (boolterm2 -> TRUE .)
    )               reduce using rule 54 (boolterm2 -> TRUE .)
    ,               reduce using rule 54 (boolterm2 -> TRUE .)
    ;               reduce using rule 54 (boolterm2 -> TRUE .)


state 42

    (63) expression -> term .
    (64) term -> term . * factor
    (65) term -> term . / factor

    <               reduce using rule 63 (expression -> term .)
    >               reduce using rule 63 (expression -> term .)
    GTEQL           reduce using rule 63 (expression -> term .)
    LTEQL           reduce using rule 63 (expression -> term .)
    NOTEQL          reduce using rule 63 (expression -> term .)
    BOOLEQL         reduce using rule 63 (expression -> term .)
    +               reduce using rule 63 (expression -> term .)
    -               reduce using rule 63 (expression -> term .)
    AND             reduce using rule 63 (expression -> term .)
    {               reduce using rule 63 (expression -> term .)
    OR              reduce using rule 63 (expression -> term .)
    VARIABLE        reduce using rule 63 (expression -> term .)
    ID              reduce using rule 63 (expression -> term .)
    WHILE           reduce using rule 63 (expression -> term .)
    FOR             reduce using rule 63 (expression -> term .)
    IF              reduce using rule 63 (expression -> term .)
    PRINT           reduce using rule 63 (expression -> term .)
    $end            reduce using rule 63 (expression -> term .)
    }               reduce using rule 63 (expression -> term .)
    RETURN          reduce using rule 63 (expression -> term .)
    )               reduce using rule 63 (expression -> term .)
    ,               reduce using rule 63 (expression -> term .)
    ;               reduce using rule 63 (expression -> term .)
    *               shift and go to state 72
    /               shift and go to state 73


state 43

    (66) term -> factor .

    *               reduce using rule 66 (term -> factor .)
    /               reduce using rule 66 (term -> factor .)
    <               reduce using rule 66 (term -> factor .)
    >               reduce using rule 66 (term -> factor .)
    GTEQL           reduce using rule 66 (term -> factor .)
    LTEQL           reduce using rule 66 (term -> factor .)
    NOTEQL          reduce using rule 66 (term -> factor .)
    BOOLEQL         reduce using rule 66 (term -> factor .)
    +               reduce using rule 66 (term -> factor .)
    -               reduce using rule 66 (term -> factor .)
    AND             reduce using rule 66 (term -> factor .)
    {               reduce using rule 66 (term -> factor .)
    OR              reduce using rule 66 (term -> factor .)
    VARIABLE        reduce using rule 66 (term -> factor .)
    ID              reduce using rule 66 (term -> factor .)
    WHILE           reduce using rule 66 (term -> factor .)
    FOR             reduce using rule 66 (term -> factor .)
    IF              reduce using rule 66 (term -> factor .)
    PRINT           reduce using rule 66 (term -> factor .)
    $end            reduce using rule 66 (term -> factor .)
    }               reduce using rule 66 (term -> factor .)
    RETURN          reduce using rule 66 (term -> factor .)
    )               reduce using rule 66 (term -> factor .)
    ,               reduce using rule 66 (term -> factor .)
    ;               reduce using rule 66 (term -> factor .)


state 44

    (67) factor -> ID .

    *               reduce using rule 67 (factor -> ID .)
    /               reduce using rule 67 (factor -> ID .)
    <               reduce using rule 67 (factor -> ID .)
    >               reduce using rule 67 (factor -> ID .)
    GTEQL           reduce using rule 67 (factor -> ID .)
    LTEQL           reduce using rule 67 (factor -> ID .)
    NOTEQL          reduce using rule 67 (factor -> ID .)
    BOOLEQL         reduce using rule 67 (factor -> ID .)
    +               reduce using rule 67 (factor -> ID .)
    -               reduce using rule 67 (factor -> ID .)
    AND             reduce using rule 67 (factor -> ID .)
    {               reduce using rule 67 (factor -> ID .)
    OR              reduce using rule 67 (factor -> ID .)
    VARIABLE        reduce using rule 67 (factor -> ID .)
    ID              reduce using rule 67 (factor -> ID .)
    WHILE           reduce using rule 67 (factor -> ID .)
    FOR             reduce using rule 67 (factor -> ID .)
    IF              reduce using rule 67 (factor -> ID .)
    PRINT           reduce using rule 67 (factor -> ID .)
    $end            reduce using rule 67 (factor -> ID .)
    }               reduce using rule 67 (factor -> ID .)
    RETURN          reduce using rule 67 (factor -> ID .)
    )               reduce using rule 67 (factor -> ID .)
    ,               reduce using rule 67 (factor -> ID .)
    ;               reduce using rule 67 (factor -> ID .)


state 45

    (68) factor -> NUMBER .

    *               reduce using rule 68 (factor -> NUMBER .)
    /               reduce using rule 68 (factor -> NUMBER .)
    <               reduce using rule 68 (factor -> NUMBER .)
    >               reduce using rule 68 (factor -> NUMBER .)
    GTEQL           reduce using rule 68 (factor -> NUMBER .)
    LTEQL           reduce using rule 68 (factor -> NUMBER .)
    NOTEQL          reduce using rule 68 (factor -> NUMBER .)
    BOOLEQL         reduce using rule 68 (factor -> NUMBER .)
    +               reduce using rule 68 (factor -> NUMBER .)
    -               reduce using rule 68 (factor -> NUMBER .)
    AND             reduce using rule 68 (factor -> NUMBER .)
    {               reduce using rule 68 (factor -> NUMBER .)
    OR              reduce using rule 68 (factor -> NUMBER .)
    VARIABLE        reduce using rule 68 (factor -> NUMBER .)
    ID              reduce using rule 68 (factor -> NUMBER .)
    WHILE           reduce using rule 68 (factor -> NUMBER .)
    FOR             reduce using rule 68 (factor -> NUMBER .)
    IF              reduce using rule 68 (factor -> NUMBER .)
    PRINT           reduce using rule 68 (factor -> NUMBER .)
    $end            reduce using rule 68 (factor -> NUMBER .)
    }               reduce using rule 68 (factor -> NUMBER .)
    RETURN          reduce using rule 68 (factor -> NUMBER .)
    )               reduce using rule 68 (factor -> NUMBER .)
    ,               reduce using rule 68 (factor -> NUMBER .)
    ;               reduce using rule 68 (factor -> NUMBER .)


state 46

    (69) factor -> ( . expression )
    (61) expression -> . expression + term
    (62) expression -> . expression - term
    (63) expression -> . term
    (64) term -> . term * factor
    (65) term -> . term / factor
    (66) term -> . factor
    (67) factor -> . ID
    (68) factor -> . NUMBER
    (69) factor -> . ( expression )

    ID              shift and go to state 44
    NUMBER          shift and go to state 45
    (               shift and go to state 46

    expression                     shift and go to state 74
    term                           shift and go to state 42
    factor                         shift and go to state 43

state 47

    (37) for -> FOR ( . initialization ; boolean ; assign ) { block }
    (38) for -> FOR ( . initialization ; boolean ; unary ) { block }
    (22) initialization -> . VARIABLE ID = STRING
    (23) initialization -> . VARIABLE ID = boolean

    VARIABLE        shift and go to state 76

    initialization                 shift and go to state 75

state 48

    (39) for -> FOR ID . IN RANGE ( expression , expression ) { block }

    IN              shift and go to state 77


state 49

    (32) if -> IF boolean . { block } elif
    (45) boolean -> boolean . OR boolterm

    {               shift and go to state 78
    OR              shift and go to state 61


state 50

    (40) print -> PRINT ( . plist )
    (41) plist -> . pstat , plist
    (42) plist -> . pstat
    (43) pstat -> . STRING
    (44) pstat -> . boolean
    (45) boolean -> . boolean OR boolterm
    (46) boolean -> . boolterm
    (47) boolterm -> . boolterm AND boolterm1
    (48) boolterm -> . boolterm1
    (49) boolterm1 -> . NOT boolterm2
    (50) boolterm1 -> . boolterm2
    (51) boolterm2 -> . condition
    (52) boolterm2 -> . expression
    (53) boolterm2 -> . FALSE
    (54) boolterm2 -> . TRUE
    (55) condition -> . expression < expression
    (56) condition -> . expression > expression
    (57) condition -> . expression GTEQL expression
    (58) condition -> . expression LTEQL expression
    (59) condition -> . expression NOTEQL expression
    (60) condition -> . expression BOOLEQL expression
    (61) expression -> . expression + term
    (62) expression -> . expression - term
    (63) expression -> . term
    (64) term -> . term * factor
    (65) term -> . term / factor
    (66) term -> . factor
    (67) factor -> . ID
    (68) factor -> . NUMBER
    (69) factor -> . ( expression )

    STRING          shift and go to state 81
    NOT             shift and go to state 36
    FALSE           shift and go to state 40
    TRUE            shift and go to state 41
    ID              shift and go to state 44
    NUMBER          shift and go to state 45
    (               shift and go to state 46

    plist                          shift and go to state 79
    pstat                          shift and go to state 80
    boolean                        shift and go to state 82
    boolterm                       shift and go to state 34
    boolterm1                      shift and go to state 35
    boolterm2                      shift and go to state 37
    condition                      shift and go to state 38
    expression                     shift and go to state 39
    term                           shift and go to state 42
    factor                         shift and go to state 43

state 51

    (4) function -> FUNCTION ID ( . argument ) { block RETURN boolean }
    (5) function -> FUNCTION ID ( . argument ) { block RETURN }
    (6) argument -> . ID , argument
    (7) argument -> . ID
    (8) argument -> . empty
    (9) empty -> .

    ID              shift and go to state 57
    )               reduce using rule 9 (empty -> .)

    argument                       shift and go to state 83
    empty                          shift and go to state 59

state 52

    (22) initialization -> VARIABLE ID = . STRING
    (23) initialization -> VARIABLE ID = . boolean
    (45) boolean -> . boolean OR boolterm
    (46) boolean -> . boolterm
    (47) boolterm -> . boolterm AND boolterm1
    (48) boolterm -> . boolterm1
    (49) boolterm1 -> . NOT boolterm2
    (50) boolterm1 -> . boolterm2
    (51) boolterm2 -> . condition
    (52) boolterm2 -> . expression
    (53) boolterm2 -> . FALSE
    (54) boolterm2 -> . TRUE
    (55) condition -> . expression < expression
    (56) condition -> . expression > expression
    (57) condition -> . expression GTEQL expression
    (58) condition -> . expression LTEQL expression
    (59) condition -> . expression NOTEQL expression
    (60) condition -> . expression BOOLEQL expression
    (61) expression -> . expression + term
    (62) expression -> . expression - term
    (63) expression -> . term
    (64) term -> . term * factor
    (65) term -> . term / factor
    (66) term -> . factor
    (67) factor -> . ID
    (68) factor -> . NUMBER
    (69) factor -> . ( expression )

    STRING          shift and go to state 84
    NOT             shift and go to state 36
    FALSE           shift and go to state 40
    TRUE            shift and go to state 41
    ID              shift and go to state 44
    NUMBER          shift and go to state 45
    (               shift and go to state 46

    boolean                        shift and go to state 85
    boolterm                       shift and go to state 34
    boolterm1                      shift and go to state 35
    boolterm2                      shift and go to state 37
    condition                      shift and go to state 38
    expression                     shift and go to state 39
    term                           shift and go to state 42
    factor                         shift and go to state 43

state 53

    (31) funcall -> ID . ( argument )
    (67) factor -> ID .

    (               shift and go to state 30
    *               reduce using rule 67 (factor -> ID .)
    /               reduce using rule 67 (factor -> ID .)
    <               reduce using rule 67 (factor -> ID .)
    >               reduce using rule 67 (factor -> ID .)
    GTEQL           reduce using rule 67 (factor -> ID .)
    LTEQL           reduce using rule 67 (factor -> ID .)
    NOTEQL          reduce using rule 67 (factor -> ID .)
    BOOLEQL         reduce using rule 67 (factor -> ID .)
    +               reduce using rule 67 (factor -> ID .)
    -               reduce using rule 67 (factor -> ID .)
    AND             reduce using rule 67 (factor -> ID .)
    OR              reduce using rule 67 (factor -> ID .)
    VARIABLE        reduce using rule 67 (factor -> ID .)
    ID              reduce using rule 67 (factor -> ID .)
    WHILE           reduce using rule 67 (factor -> ID .)
    FOR             reduce using rule 67 (factor -> ID .)
    IF              reduce using rule 67 (factor -> ID .)
    PRINT           reduce using rule 67 (factor -> ID .)
    $end            reduce using rule 67 (factor -> ID .)
    }               reduce using rule 67 (factor -> ID .)
    RETURN          reduce using rule 67 (factor -> ID .)
    )               reduce using rule 67 (factor -> ID .)


state 54

    (24) assign -> ID = STRING .

    VARIABLE        reduce using rule 24 (assign -> ID = STRING .)
    ID              reduce using rule 24 (assign -> ID = STRING .)
    WHILE           reduce using rule 24 (assign -> ID = STRING .)
    FOR             reduce using rule 24 (assign -> ID = STRING .)
    IF              reduce using rule 24 (assign -> ID = STRING .)
    PRINT           reduce using rule 24 (assign -> ID = STRING .)
    $end            reduce using rule 24 (assign -> ID = STRING .)
    }               reduce using rule 24 (assign -> ID = STRING .)
    RETURN          reduce using rule 24 (assign -> ID = STRING .)
    )               reduce using rule 24 (assign -> ID = STRING .)


state 55

    (25) assign -> ID = boolean .
    (45) boolean -> boolean . OR boolterm

    VARIABLE        reduce using rule 25 (assign -> ID = boolean .)
    ID              reduce using rule 25 (assign -> ID = boolean .)
    WHILE           reduce using rule 25 (assign -> ID = boolean .)
    FOR             reduce using rule 25 (assign -> ID = boolean .)
    IF              reduce using rule 25 (assign -> ID = boolean .)
    PRINT           reduce using rule 25 (assign -> ID = boolean .)
    $end            reduce using rule 25 (assign -> ID = boolean .)
    }               reduce using rule 25 (assign -> ID = boolean .)
    RETURN          reduce using rule 25 (assign -> ID = boolean .)
    )               reduce using rule 25 (assign -> ID = boolean .)
    OR              shift and go to state 61


state 56

    (26) assign -> ID = funcall .

    VARIABLE        reduce using rule 26 (assign -> ID = funcall .)
    ID              reduce using rule 26 (assign -> ID = funcall .)
    WHILE           reduce using rule 26 (assign -> ID = funcall .)
    FOR             reduce using rule 26 (assign -> ID = funcall .)
    IF              reduce using rule 26 (assign -> ID = funcall .)
    PRINT           reduce using rule 26 (assign -> ID = funcall .)
    $end            reduce using rule 26 (assign -> ID = funcall .)
    }               reduce using rule 26 (assign -> ID = funcall .)
    RETURN          reduce using rule 26 (assign -> ID = funcall .)
    )               reduce using rule 26 (assign -> ID = funcall .)


state 57

    (6) argument -> ID . , argument
    (7) argument -> ID .

    ,               shift and go to state 86
    )               reduce using rule 7 (argument -> ID .)


state 58

    (31) funcall -> ID ( argument . )

    )               shift and go to state 87


state 59

    (8) argument -> empty .

    )               reduce using rule 8 (argument -> empty .)


state 60

    (36) while -> WHILE boolean { . block }
    (10) block -> . statement block
    (11) block -> . statement
    (12) statement -> . declaration
    (13) statement -> . initialization
    (14) statement -> . assign
    (15) statement -> . funcall
    (16) statement -> . unary
    (17) statement -> . while
    (18) statement -> . for
    (19) statement -> . if
    (20) statement -> . print
    (21) declaration -> . VARIABLE ID
    (22) initialization -> . VARIABLE ID = STRING
    (23) initialization -> . VARIABLE ID = boolean
    (24) assign -> . ID = STRING
    (25) assign -> . ID = boolean
    (26) assign -> . ID = funcall
    (31) funcall -> . ID ( argument )
    (27) unary -> . increment
    (28) unary -> . decrement
    (36) while -> . WHILE boolean { block }
    (37) for -> . FOR ( initialization ; boolean ; assign ) { block }
    (38) for -> . FOR ( initialization ; boolean ; unary ) { block }
    (39) for -> . FOR ID IN RANGE ( expression , expression ) { block }
    (32) if -> . IF boolean { block } elif
    (40) print -> . PRINT ( plist )
    (29) increment -> . ID INCRMNT
    (30) decrement -> . ID DECRMNT

    VARIABLE        shift and go to state 17
    ID              shift and go to state 18
    WHILE           shift and go to state 21
    FOR             shift and go to state 22
    IF              shift and go to state 23
    PRINT           shift and go to state 24

    block                          shift and go to state 88
    statement                      shift and go to state 7
    declaration                    shift and go to state 8
    initialization                 shift and go to state 9
    assign                         shift and go to state 10
    funcall                        shift and go to state 11
    unary                          shift and go to state 12
    while                          shift and go to state 13
    for                            shift and go to state 14
    if                             shift and go to state 15
    print                          shift and go to state 16
    increment                      shift and go to state 19
    decrement                      shift and go to state 20

state 61

    (45) boolean -> boolean OR . boolterm
    (47) boolterm -> . boolterm AND boolterm1
    (48) boolterm -> . boolterm1
    (49) boolterm1 -> . NOT boolterm2
    (50) boolterm1 -> . boolterm2
    (51) boolterm2 -> . condition
    (52) boolterm2 -> . expression
    (53) boolterm2 -> . FALSE
    (54) boolterm2 -> . TRUE
    (55) condition -> . expression < expression
    (56) condition -> . expression > expression
    (57) condition -> . expression GTEQL expression
    (58) condition -> . expression LTEQL expression
    (59) condition -> . expression NOTEQL expression
    (60) condition -> . expression BOOLEQL expression
    (61) expression -> . expression + term
    (62) expression -> . expression - term
    (63) expression -> . term
    (64) term -> . term * factor
    (65) term -> . term / factor
    (66) term -> . factor
    (67) factor -> . ID
    (68) factor -> . NUMBER
    (69) factor -> . ( expression )

    NOT             shift and go to state 36
    FALSE           shift and go to state 40
    TRUE            shift and go to state 41
    ID              shift and go to state 44
    NUMBER          shift and go to state 45
    (               shift and go to state 46

    boolterm                       shift and go to state 89
    boolterm1                      shift and go to state 35
    boolterm2                      shift and go to state 37
    condition                      shift and go to state 38
    expression                     shift and go to state 39
    term                           shift and go to state 42
    factor                         shift and go to state 43

state 62

    (47) boolterm -> boolterm AND . boolterm1
    (49) boolterm1 -> . NOT boolterm2
    (50) boolterm1 -> . boolterm2
    (51) boolterm2 -> . condition
    (52) boolterm2 -> . expression
    (53) boolterm2 -> . FALSE
    (54) boolterm2 -> . TRUE
    (55) condition -> . expression < expression
    (56) condition -> . expression > expression
    (57) condition -> . expression GTEQL expression
    (58) condition -> . expression LTEQL expression
    (59) condition -> . expression NOTEQL expression
    (60) condition -> . expression BOOLEQL expression
    (61) expression -> . expression + term
    (62) expression -> . expression - term
    (63) expression -> . term
    (64) term -> . term * factor
    (65) term -> . term / factor
    (66) term -> . factor
    (67) factor -> . ID
    (68) factor -> . NUMBER
    (69) factor -> . ( expression )

    NOT             shift and go to state 36
    FALSE           shift and go to state 40
    TRUE            shift and go to state 41
    ID              shift and go to state 44
    NUMBER          shift and go to state 45
    (               shift and go to state 46

    boolterm1                      shift and go to state 90
    boolterm2                      shift and go to state 37
    condition                      shift and go to state 38
    expression                     shift and go to state 39
    term                           shift and go to state 42
    factor                         shift and go to state 43

state 63

    (49) boolterm1 -> NOT boolterm2 .

    AND             reduce using rule 49 (boolterm1 -> NOT boolterm2 .)
    {               reduce using rule 49 (boolterm1 -> NOT boolterm2 .)
    OR              reduce using rule 49 (boolterm1 -> NOT boolterm2 .)
    VARIABLE        reduce using rule 49 (boolterm1 -> NOT boolterm2 .)
    ID              reduce using rule 49 (boolterm1 -> NOT boolterm2 .)
    WHILE           reduce using rule 49 (boolterm1 -> NOT boolterm2 .)
    FOR             reduce using rule 49 (boolterm1 -> NOT boolterm2 .)
    IF              reduce using rule 49 (boolterm1 -> NOT boolterm2 .)
    PRINT           reduce using rule 49 (boolterm1 -> NOT boolterm2 .)
    $end            reduce using rule 49 (boolterm1 -> NOT boolterm2 .)
    }               reduce using rule 49 (boolterm1 -> NOT boolterm2 .)
    RETURN          reduce using rule 49 (boolterm1 -> NOT boolterm2 .)
    )               reduce using rule 49 (boolterm1 -> NOT boolterm2 .)
    ,               reduce using rule 49 (boolterm1 -> NOT boolterm2 .)
    ;               reduce using rule 49 (boolterm1 -> NOT boolterm2 .)


state 64

    (55) condition -> expression < . expression
    (61) expression -> . expression + term
    (62) expression -> . expression - term
    (63) expression -> . term
    (64) term -> . term * factor
    (65) term -> . term / factor
    (66) term -> . factor
    (67) factor -> . ID
    (68) factor -> . NUMBER
    (69) factor -> . ( expression )

    ID              shift and go to state 44
    NUMBER          shift and go to state 45
    (               shift and go to state 46

    expression                     shift and go to state 91
    term                           shift and go to state 42
    factor                         shift and go to state 43

state 65

    (56) condition -> expression > . expression
    (61) expression -> . expression + term
    (62) expression -> . expression - term
    (63) expression -> . term
    (64) term -> . term * factor
    (65) term -> . term / factor
    (66) term -> . factor
    (67) factor -> . ID
    (68) factor -> . NUMBER
    (69) factor -> . ( expression )

    ID              shift and go to state 44
    NUMBER          shift and go to state 45
    (               shift and go to state 46

    expression                     shift and go to state 92
    term                           shift and go to state 42
    factor                         shift and go to state 43

state 66

    (57) condition -> expression GTEQL . expression
    (61) expression -> . expression + term
    (62) expression -> . expression - term
    (63) expression -> . term
    (64) term -> . term * factor
    (65) term -> . term / factor
    (66) term -> . factor
    (67) factor -> . ID
    (68) factor -> . NUMBER
    (69) factor -> . ( expression )

    ID              shift and go to state 44
    NUMBER          shift and go to state 45
    (               shift and go to state 46

    expression                     shift and go to state 93
    term                           shift and go to state 42
    factor                         shift and go to state 43

state 67

    (58) condition -> expression LTEQL . expression
    (61) expression -> . expression + term
    (62) expression -> . expression - term
    (63) expression -> . term
    (64) term -> . term * factor
    (65) term -> . term / factor
    (66) term -> . factor
    (67) factor -> . ID
    (68) factor -> . NUMBER
    (69) factor -> . ( expression )

    ID              shift and go to state 44
    NUMBER          shift and go to state 45
    (               shift and go to state 46

    expression                     shift and go to state 94
    term                           shift and go to state 42
    factor                         shift and go to state 43

state 68

    (59) condition -> expression NOTEQL . expression
    (61) expression -> . expression + term
    (62) expression -> . expression - term
    (63) expression -> . term
    (64) term -> . term * factor
    (65) term -> . term / factor
    (66) term -> . factor
    (67) factor -> . ID
    (68) factor -> . NUMBER
    (69) factor -> . ( expression )

    ID              shift and go to state 44
    NUMBER          shift and go to state 45
    (               shift and go to state 46

    expression                     shift and go to state 95
    term                           shift and go to state 42
    factor                         shift and go to state 43

state 69

    (60) condition -> expression BOOLEQL . expression
    (61) expression -> . expression + term
    (62) expression -> . expression - term
    (63) expression -> . term
    (64) term -> . term * factor
    (65) term -> . term / factor
    (66) term -> . factor
    (67) factor -> . ID
    (68) factor -> . NUMBER
    (69) factor -> . ( expression )

    ID              shift and go to state 44
    NUMBER          shift and go to state 45
    (               shift and go to state 46

    expression                     shift and go to state 96
    term                           shift and go to state 42
    factor                         shift and go to state 43

state 70

    (61) expression -> expression + . term
    (64) term -> . term * factor
    (65) term -> . term / factor
    (66) term -> . factor
    (67) factor -> . ID
    (68) factor -> . NUMBER
    (69) factor -> . ( expression )

    ID              shift and go to state 44
    NUMBER          shift and go to state 45
    (               shift and go to state 46

    term                           shift and go to state 97
    factor                         shift and go to state 43

state 71

    (62) expression -> expression - . term
    (64) term -> . term * factor
    (65) term -> . term / factor
    (66) term -> . factor
    (67) factor -> . ID
    (68) factor -> . NUMBER
    (69) factor -> . ( expression )

    ID              shift and go to state 44
    NUMBER          shift and go to state 45
    (               shift and go to state 46

    term                           shift and go to state 98
    factor                         shift and go to state 43

state 72

    (64) term -> term * . factor
    (67) factor -> . ID
    (68) factor -> . NUMBER
    (69) factor -> . ( expression )

    ID              shift and go to state 44
    NUMBER          shift and go to state 45
    (               shift and go to state 46

    factor                         shift and go to state 99

state 73

    (65) term -> term / . factor
    (67) factor -> . ID
    (68) factor -> . NUMBER
    (69) factor -> . ( expression )

    ID              shift and go to state 44
    NUMBER          shift and go to state 45
    (               shift and go to state 46

    factor                         shift and go to state 100

state 74

    (69) factor -> ( expression . )
    (61) expression -> expression . + term
    (62) expression -> expression . - term

    )               shift and go to state 101
    +               shift and go to state 70
    -               shift and go to state 71


state 75

    (37) for -> FOR ( initialization . ; boolean ; assign ) { block }
    (38) for -> FOR ( initialization . ; boolean ; unary ) { block }

    ;               shift and go to state 102


state 76

    (22) initialization -> VARIABLE . ID = STRING
    (23) initialization -> VARIABLE . ID = boolean

    ID              shift and go to state 103


state 77

    (39) for -> FOR ID IN . RANGE ( expression , expression ) { block }

    RANGE           shift and go to state 104


state 78

    (32) if -> IF boolean { . block } elif
    (10) block -> . statement block
    (11) block -> . statement
    (12) statement -> . declaration
    (13) statement -> . initialization
    (14) statement -> . assign
    (15) statement -> . funcall
    (16) statement -> . unary
    (17) statement -> . while
    (18) statement -> . for
    (19) statement -> . if
    (20) statement -> . print
    (21) declaration -> . VARIABLE ID
    (22) initialization -> . VARIABLE ID = STRING
    (23) initialization -> . VARIABLE ID = boolean
    (24) assign -> . ID = STRING
    (25) assign -> . ID = boolean
    (26) assign -> . ID = funcall
    (31) funcall -> . ID ( argument )
    (27) unary -> . increment
    (28) unary -> . decrement
    (36) while -> . WHILE boolean { block }
    (37) for -> . FOR ( initialization ; boolean ; assign ) { block }
    (38) for -> . FOR ( initialization ; boolean ; unary ) { block }
    (39) for -> . FOR ID IN RANGE ( expression , expression ) { block }
    (32) if -> . IF boolean { block } elif
    (40) print -> . PRINT ( plist )
    (29) increment -> . ID INCRMNT
    (30) decrement -> . ID DECRMNT

    VARIABLE        shift and go to state 17
    ID              shift and go to state 18
    WHILE           shift and go to state 21
    FOR             shift and go to state 22
    IF              shift and go to state 23
    PRINT           shift and go to state 24

    block                          shift and go to state 105
    statement                      shift and go to state 7
    declaration                    shift and go to state 8
    initialization                 shift and go to state 9
    assign                         shift and go to state 10
    funcall                        shift and go to state 11
    unary                          shift and go to state 12
    while                          shift and go to state 13
    for                            shift and go to state 14
    if                             shift and go to state 15
    print                          shift and go to state 16
    increment                      shift and go to state 19
    decrement                      shift and go to state 20

state 79

    (40) print -> PRINT ( plist . )

    )               shift and go to state 106


state 80

    (41) plist -> pstat . , plist
    (42) plist -> pstat .

    ,               shift and go to state 107
    )               reduce using rule 42 (plist -> pstat .)


state 81

    (43) pstat -> STRING .

    ,               reduce using rule 43 (pstat -> STRING .)
    )               reduce using rule 43 (pstat -> STRING .)


state 82

    (44) pstat -> boolean .
    (45) boolean -> boolean . OR boolterm

    ,               reduce using rule 44 (pstat -> boolean .)
    )               reduce using rule 44 (pstat -> boolean .)
    OR              shift and go to state 61


state 83

    (4) function -> FUNCTION ID ( argument . ) { block RETURN boolean }
    (5) function -> FUNCTION ID ( argument . ) { block RETURN }

    )               shift and go to state 108


state 84

    (22) initialization -> VARIABLE ID = STRING .

    VARIABLE        reduce using rule 22 (initialization -> VARIABLE ID = STRING .)
    ID              reduce using rule 22 (initialization -> VARIABLE ID = STRING .)
    WHILE           reduce using rule 22 (initialization -> VARIABLE ID = STRING .)
    FOR             reduce using rule 22 (initialization -> VARIABLE ID = STRING .)
    IF              reduce using rule 22 (initialization -> VARIABLE ID = STRING .)
    PRINT           reduce using rule 22 (initialization -> VARIABLE ID = STRING .)
    $end            reduce using rule 22 (initialization -> VARIABLE ID = STRING .)
    }               reduce using rule 22 (initialization -> VARIABLE ID = STRING .)
    RETURN          reduce using rule 22 (initialization -> VARIABLE ID = STRING .)
    ;               reduce using rule 22 (initialization -> VARIABLE ID = STRING .)


state 85

    (23) initialization -> VARIABLE ID = boolean .
    (45) boolean -> boolean . OR boolterm

    VARIABLE        reduce using rule 23 (initialization -> VARIABLE ID = boolean .)
    ID              reduce using rule 23 (initialization -> VARIABLE ID = boolean .)
    WHILE           reduce using rule 23 (initialization -> VARIABLE ID = boolean .)
    FOR             reduce using rule 23 (initialization -> VARIABLE ID = boolean .)
    IF              reduce using rule 23 (initialization -> VARIABLE ID = boolean .)
    PRINT           reduce using rule 23 (initialization -> VARIABLE ID = boolean .)
    $end            reduce using rule 23 (initialization -> VARIABLE ID = boolean .)
    }               reduce using rule 23 (initialization -> VARIABLE ID = boolean .)
    RETURN          reduce using rule 23 (initialization -> VARIABLE ID = boolean .)
    ;               reduce using rule 23 (initialization -> VARIABLE ID = boolean .)
    OR              shift and go to state 61


state 86

    (6) argument -> ID , . argument
    (6) argument -> . ID , argument
    (7) argument -> . ID
    (8) argument -> . empty
    (9) empty -> .

    ID              shift and go to state 57
    )               reduce using rule 9 (empty -> .)

    argument                       shift and go to state 109
    empty                          shift and go to state 59

state 87

    (31) funcall -> ID ( argument ) .

    VARIABLE        reduce using rule 31 (funcall -> ID ( argument ) .)
    ID              reduce using rule 31 (funcall -> ID ( argument ) .)
    WHILE           reduce using rule 31 (funcall -> ID ( argument ) .)
    FOR             reduce using rule 31 (funcall -> ID ( argument ) .)
    IF              reduce using rule 31 (funcall -> ID ( argument ) .)
    PRINT           reduce using rule 31 (funcall -> ID ( argument ) .)
    $end            reduce using rule 31 (funcall -> ID ( argument ) .)
    }               reduce using rule 31 (funcall -> ID ( argument ) .)
    RETURN          reduce using rule 31 (funcall -> ID ( argument ) .)
    )               reduce using rule 31 (funcall -> ID ( argument ) .)


state 88

    (36) while -> WHILE boolean { block . }

    }               shift and go to state 110


state 89

    (45) boolean -> boolean OR boolterm .
    (47) boolterm -> boolterm . AND boolterm1

    {               reduce using rule 45 (boolean -> boolean OR boolterm .)
    OR              reduce using rule 45 (boolean -> boolean OR boolterm .)
    VARIABLE        reduce using rule 45 (boolean -> boolean OR boolterm .)
    ID              reduce using rule 45 (boolean -> boolean OR boolterm .)
    WHILE           reduce using rule 45 (boolean -> boolean OR boolterm .)
    FOR             reduce using rule 45 (boolean -> boolean OR boolterm .)
    IF              reduce using rule 45 (boolean -> boolean OR boolterm .)
    PRINT           reduce using rule 45 (boolean -> boolean OR boolterm .)
    $end            reduce using rule 45 (boolean -> boolean OR boolterm .)
    }               reduce using rule 45 (boolean -> boolean OR boolterm .)
    RETURN          reduce using rule 45 (boolean -> boolean OR boolterm .)
    )               reduce using rule 45 (boolean -> boolean OR boolterm .)
    ,               reduce using rule 45 (boolean -> boolean OR boolterm .)
    ;               reduce using rule 45 (boolean -> boolean OR boolterm .)
    AND             shift and go to state 62


state 90

    (47) boolterm -> boolterm AND boolterm1 .

    AND             reduce using rule 47 (boolterm -> boolterm AND boolterm1 .)
    {               reduce using rule 47 (boolterm -> boolterm AND boolterm1 .)
    OR              reduce using rule 47 (boolterm -> boolterm AND boolterm1 .)
    VARIABLE        reduce using rule 47 (boolterm -> boolterm AND boolterm1 .)
    ID              reduce using rule 47 (boolterm -> boolterm AND boolterm1 .)
    WHILE           reduce using rule 47 (boolterm -> boolterm AND boolterm1 .)
    FOR             reduce using rule 47 (boolterm -> boolterm AND boolterm1 .)
    IF              reduce using rule 47 (boolterm -> boolterm AND boolterm1 .)
    PRINT           reduce using rule 47 (boolterm -> boolterm AND boolterm1 .)
    $end            reduce using rule 47 (boolterm -> boolterm AND boolterm1 .)
    }               reduce using rule 47 (boolterm -> boolterm AND boolterm1 .)
    RETURN          reduce using rule 47 (boolterm -> boolterm AND boolterm1 .)
    )               reduce using rule 47 (boolterm -> boolterm AND boolterm1 .)
    ,               reduce using rule 47 (boolterm -> boolterm AND boolterm1 .)
    ;               reduce using rule 47 (boolterm -> boolterm AND boolterm1 .)


state 91

    (55) condition -> expression < expression .
    (61) expression -> expression . + term
    (62) expression -> expression . - term

    AND             reduce using rule 55 (condition -> expression < expression .)
    {               reduce using rule 55 (condition -> expression < expression .)
    OR              reduce using rule 55 (condition -> expression < expression .)
    VARIABLE        reduce using rule 55 (condition -> expression < expression .)
    ID              reduce using rule 55 (condition -> expression < expression .)
    WHILE           reduce using rule 55 (condition -> expression < expression .)
    FOR             reduce using rule 55 (condition -> expression < expression .)
    IF              reduce using rule 55 (condition -> expression < expression .)
    PRINT           reduce using rule 55 (condition -> expression < expression .)
    $end            reduce using rule 55 (condition -> expression < expression .)
    }               reduce using rule 55 (condition -> expression < expression .)
    RETURN          reduce using rule 55 (condition -> expression < expression .)
    )               reduce using rule 55 (condition -> expression < expression .)
    ,               reduce using rule 55 (condition -> expression < expression .)
    ;               reduce using rule 55 (condition -> expression < expression .)
    +               shift and go to state 70
    -               shift and go to state 71


state 92

    (56) condition -> expression > expression .
    (61) expression -> expression . + term
    (62) expression -> expression . - term

    AND             reduce using rule 56 (condition -> expression > expression .)
    {               reduce using rule 56 (condition -> expression > expression .)
    OR              reduce using rule 56 (condition -> expression > expression .)
    VARIABLE        reduce using rule 56 (condition -> expression > expression .)
    ID              reduce using rule 56 (condition -> expression > expression .)
    WHILE           reduce using rule 56 (condition -> expression > expression .)
    FOR             reduce using rule 56 (condition -> expression > expression .)
    IF              reduce using rule 56 (condition -> expression > expression .)
    PRINT           reduce using rule 56 (condition -> expression > expression .)
    $end            reduce using rule 56 (condition -> expression > expression .)
    }               reduce using rule 56 (condition -> expression > expression .)
    RETURN          reduce using rule 56 (condition -> expression > expression .)
    )               reduce using rule 56 (condition -> expression > expression .)
    ,               reduce using rule 56 (condition -> expression > expression .)
    ;               reduce using rule 56 (condition -> expression > expression .)
    +               shift and go to state 70
    -               shift and go to state 71


state 93

    (57) condition -> expression GTEQL expression .
    (61) expression -> expression . + term
    (62) expression -> expression . - term

    AND             reduce using rule 57 (condition -> expression GTEQL expression .)
    {               reduce using rule 57 (condition -> expression GTEQL expression .)
    OR              reduce using rule 57 (condition -> expression GTEQL expression .)
    VARIABLE        reduce using rule 57 (condition -> expression GTEQL expression .)
    ID              reduce using rule 57 (condition -> expression GTEQL expression .)
    WHILE           reduce using rule 57 (condition -> expression GTEQL expression .)
    FOR             reduce using rule 57 (condition -> expression GTEQL expression .)
    IF              reduce using rule 57 (condition -> expression GTEQL expression .)
    PRINT           reduce using rule 57 (condition -> expression GTEQL expression .)
    $end            reduce using rule 57 (condition -> expression GTEQL expression .)
    }               reduce using rule 57 (condition -> expression GTEQL expression .)
    RETURN          reduce using rule 57 (condition -> expression GTEQL expression .)
    )               reduce using rule 57 (condition -> expression GTEQL expression .)
    ,               reduce using rule 57 (condition -> expression GTEQL expression .)
    ;               reduce using rule 57 (condition -> expression GTEQL expression .)
    +               shift and go to state 70
    -               shift and go to state 71


state 94

    (58) condition -> expression LTEQL expression .
    (61) expression -> expression . + term
    (62) expression -> expression . - term

    AND             reduce using rule 58 (condition -> expression LTEQL expression .)
    {               reduce using rule 58 (condition -> expression LTEQL expression .)
    OR              reduce using rule 58 (condition -> expression LTEQL expression .)
    VARIABLE        reduce using rule 58 (condition -> expression LTEQL expression .)
    ID              reduce using rule 58 (condition -> expression LTEQL expression .)
    WHILE           reduce using rule 58 (condition -> expression LTEQL expression .)
    FOR             reduce using rule 58 (condition -> expression LTEQL expression .)
    IF              reduce using rule 58 (condition -> expression LTEQL expression .)
    PRINT           reduce using rule 58 (condition -> expression LTEQL expression .)
    $end            reduce using rule 58 (condition -> expression LTEQL expression .)
    }               reduce using rule 58 (condition -> expression LTEQL expression .)
    RETURN          reduce using rule 58 (condition -> expression LTEQL expression .)
    )               reduce using rule 58 (condition -> expression LTEQL expression .)
    ,               reduce using rule 58 (condition -> expression LTEQL expression .)
    ;               reduce using rule 58 (condition -> expression LTEQL expression .)
    +               shift and go to state 70
    -               shift and go to state 71


state 95

    (59) condition -> expression NOTEQL expression .
    (61) expression -> expression . + term
    (62) expression -> expression . - term

    AND             reduce using rule 59 (condition -> expression NOTEQL expression .)
    {               reduce using rule 59 (condition -> expression NOTEQL expression .)
    OR              reduce using rule 59 (condition -> expression NOTEQL expression .)
    VARIABLE        reduce using rule 59 (condition -> expression NOTEQL expression .)
    ID              reduce using rule 59 (condition -> expression NOTEQL expression .)
    WHILE           reduce using rule 59 (condition -> expression NOTEQL expression .)
    FOR             reduce using rule 59 (condition -> expression NOTEQL expression .)
    IF              reduce using rule 59 (condition -> expression NOTEQL expression .)
    PRINT           reduce using rule 59 (condition -> expression NOTEQL expression .)
    $end            reduce using rule 59 (condition -> expression NOTEQL expression .)
    }               reduce using rule 59 (condition -> expression NOTEQL expression .)
    RETURN          reduce using rule 59 (condition -> expression NOTEQL expression .)
    )               reduce using rule 59 (condition -> expression NOTEQL expression .)
    ,               reduce using rule 59 (condition -> expression NOTEQL expression .)
    ;               reduce using rule 59 (condition -> expression NOTEQL expression .)
    +               shift and go to state 70
    -               shift and go to state 71


state 96

    (60) condition -> expression BOOLEQL expression .
    (61) expression -> expression . + term
    (62) expression -> expression . - term

    AND             reduce using rule 60 (condition -> expression BOOLEQL expression .)
    {               reduce using rule 60 (condition -> expression BOOLEQL expression .)
    OR              reduce using rule 60 (condition -> expression BOOLEQL expression .)
    VARIABLE        reduce using rule 60 (condition -> expression BOOLEQL expression .)
    ID              reduce using rule 60 (condition -> expression BOOLEQL expression .)
    WHILE           reduce using rule 60 (condition -> expression BOOLEQL expression .)
    FOR             reduce using rule 60 (condition -> expression BOOLEQL expression .)
    IF              reduce using rule 60 (condition -> expression BOOLEQL expression .)
    PRINT           reduce using rule 60 (condition -> expression BOOLEQL expression .)
    $end            reduce using rule 60 (condition -> expression BOOLEQL expression .)
    }               reduce using rule 60 (condition -> expression BOOLEQL expression .)
    RETURN          reduce using rule 60 (condition -> expression BOOLEQL expression .)
    )               reduce using rule 60 (condition -> expression BOOLEQL expression .)
    ,               reduce using rule 60 (condition -> expression BOOLEQL expression .)
    ;               reduce using rule 60 (condition -> expression BOOLEQL expression .)
    +               shift and go to state 70
    -               shift and go to state 71


state 97

    (61) expression -> expression + term .
    (64) term -> term . * factor
    (65) term -> term . / factor

    <               reduce using rule 61 (expression -> expression + term .)
    >               reduce using rule 61 (expression -> expression + term .)
    GTEQL           reduce using rule 61 (expression -> expression + term .)
    LTEQL           reduce using rule 61 (expression -> expression + term .)
    NOTEQL          reduce using rule 61 (expression -> expression + term .)
    BOOLEQL         reduce using rule 61 (expression -> expression + term .)
    +               reduce using rule 61 (expression -> expression + term .)
    -               reduce using rule 61 (expression -> expression + term .)
    AND             reduce using rule 61 (expression -> expression + term .)
    {               reduce using rule 61 (expression -> expression + term .)
    OR              reduce using rule 61 (expression -> expression + term .)
    VARIABLE        reduce using rule 61 (expression -> expression + term .)
    ID              reduce using rule 61 (expression -> expression + term .)
    WHILE           reduce using rule 61 (expression -> expression + term .)
    FOR             reduce using rule 61 (expression -> expression + term .)
    IF              reduce using rule 61 (expression -> expression + term .)
    PRINT           reduce using rule 61 (expression -> expression + term .)
    $end            reduce using rule 61 (expression -> expression + term .)
    }               reduce using rule 61 (expression -> expression + term .)
    RETURN          reduce using rule 61 (expression -> expression + term .)
    )               reduce using rule 61 (expression -> expression + term .)
    ,               reduce using rule 61 (expression -> expression + term .)
    ;               reduce using rule 61 (expression -> expression + term .)
    *               shift and go to state 72
    /               shift and go to state 73


state 98

    (62) expression -> expression - term .
    (64) term -> term . * factor
    (65) term -> term . / factor

    <               reduce using rule 62 (expression -> expression - term .)
    >               reduce using rule 62 (expression -> expression - term .)
    GTEQL           reduce using rule 62 (expression -> expression - term .)
    LTEQL           reduce using rule 62 (expression -> expression - term .)
    NOTEQL          reduce using rule 62 (expression -> expression - term .)
    BOOLEQL         reduce using rule 62 (expression -> expression - term .)
    +               reduce using rule 62 (expression -> expression - term .)
    -               reduce using rule 62 (expression -> expression - term .)
    AND             reduce using rule 62 (expression -> expression - term .)
    {               reduce using rule 62 (expression -> expression - term .)
    OR              reduce using rule 62 (expression -> expression - term .)
    VARIABLE        reduce using rule 62 (expression -> expression - term .)
    ID              reduce using rule 62 (expression -> expression - term .)
    WHILE           reduce using rule 62 (expression -> expression - term .)
    FOR             reduce using rule 62 (expression -> expression - term .)
    IF              reduce using rule 62 (expression -> expression - term .)
    PRINT           reduce using rule 62 (expression -> expression - term .)
    $end            reduce using rule 62 (expression -> expression - term .)
    }               reduce using rule 62 (expression -> expression - term .)
    RETURN          reduce using rule 62 (expression -> expression - term .)
    )               reduce using rule 62 (expression -> expression - term .)
    ,               reduce using rule 62 (expression -> expression - term .)
    ;               reduce using rule 62 (expression -> expression - term .)
    *               shift and go to state 72
    /               shift and go to state 73


state 99

    (64) term -> term * factor .

    *               reduce using rule 64 (term -> term * factor .)
    /               reduce using rule 64 (term -> term * factor .)
    <               reduce using rule 64 (term -> term * factor .)
    >               reduce using rule 64 (term -> term * factor .)
    GTEQL           reduce using rule 64 (term -> term * factor .)
    LTEQL           reduce using rule 64 (term -> term * factor .)
    NOTEQL          reduce using rule 64 (term -> term * factor .)
    BOOLEQL         reduce using rule 64 (term -> term * factor .)
    +               reduce using rule 64 (term -> term * factor .)
    -               reduce using rule 64 (term -> term * factor .)
    AND             reduce using rule 64 (term -> term * factor .)
    {               reduce using rule 64 (term -> term * factor .)
    OR              reduce using rule 64 (term -> term * factor .)
    VARIABLE        reduce using rule 64 (term -> term * factor .)
    ID              reduce using rule 64 (term -> term * factor .)
    WHILE           reduce using rule 64 (term -> term * factor .)
    FOR             reduce using rule 64 (term -> term * factor .)
    IF              reduce using rule 64 (term -> term * factor .)
    PRINT           reduce using rule 64 (term -> term * factor .)
    $end            reduce using rule 64 (term -> term * factor .)
    }               reduce using rule 64 (term -> term * factor .)
    RETURN          reduce using rule 64 (term -> term * factor .)
    )               reduce using rule 64 (term -> term * factor .)
    ,               reduce using rule 64 (term -> term * factor .)
    ;               reduce using rule 64 (term -> term * factor .)


state 100

    (65) term -> term / factor .

    *               reduce using rule 65 (term -> term / factor .)
    /               reduce using rule 65 (term -> term / factor .)
    <               reduce using rule 65 (term -> term / factor .)
    >               reduce using rule 65 (term -> term / factor .)
    GTEQL           reduce using rule 65 (term -> term / factor .)
    LTEQL           reduce using rule 65 (term -> term / factor .)
    NOTEQL          reduce using rule 65 (term -> term / factor .)
    BOOLEQL         reduce using rule 65 (term -> term / factor .)
    +               reduce using rule 65 (term -> term / factor .)
    -               reduce using rule 65 (term -> term / factor .)
    AND             reduce using rule 65 (term -> term / factor .)
    {               reduce using rule 65 (term -> term / factor .)
    OR              reduce using rule 65 (term -> term / factor .)
    VARIABLE        reduce using rule 65 (term -> term / factor .)
    ID              reduce using rule 65 (term -> term / factor .)
    WHILE           reduce using rule 65 (term -> term / factor .)
    FOR             reduce using rule 65 (term -> term / factor .)
    IF              reduce using rule 65 (term -> term / factor .)
    PRINT           reduce using rule 65 (term -> term / factor .)
    $end            reduce using rule 65 (term -> term / factor .)
    }               reduce using rule 65 (term -> term / factor .)
    RETURN          reduce using rule 65 (term -> term / factor .)
    )               reduce using rule 65 (term -> term / factor .)
    ,               reduce using rule 65 (term -> term / factor .)
    ;               reduce using rule 65 (term -> term / factor .)


state 101

    (69) factor -> ( expression ) .

    *               reduce using rule 69 (factor -> ( expression ) .)
    /               reduce using rule 69 (factor -> ( expression ) .)
    <               reduce using rule 69 (factor -> ( expression ) .)
    >               reduce using rule 69 (factor -> ( expression ) .)
    GTEQL           reduce using rule 69 (factor -> ( expression ) .)
    LTEQL           reduce using rule 69 (factor -> ( expression ) .)
    NOTEQL          reduce using rule 69 (factor -> ( expression ) .)
    BOOLEQL         reduce using rule 69 (factor -> ( expression ) .)
    +               reduce using rule 69 (factor -> ( expression ) .)
    -               reduce using rule 69 (factor -> ( expression ) .)
    AND             reduce using rule 69 (factor -> ( expression ) .)
    {               reduce using rule 69 (factor -> ( expression ) .)
    OR              reduce using rule 69 (factor -> ( expression ) .)
    VARIABLE        reduce using rule 69 (factor -> ( expression ) .)
    ID              reduce using rule 69 (factor -> ( expression ) .)
    WHILE           reduce using rule 69 (factor -> ( expression ) .)
    FOR             reduce using rule 69 (factor -> ( expression ) .)
    IF              reduce using rule 69 (factor -> ( expression ) .)
    PRINT           reduce using rule 69 (factor -> ( expression ) .)
    $end            reduce using rule 69 (factor -> ( expression ) .)
    }               reduce using rule 69 (factor -> ( expression ) .)
    RETURN          reduce using rule 69 (factor -> ( expression ) .)
    )               reduce using rule 69 (factor -> ( expression ) .)
    ,               reduce using rule 69 (factor -> ( expression ) .)
    ;               reduce using rule 69 (factor -> ( expression ) .)


state 102

    (37) for -> FOR ( initialization ; . boolean ; assign ) { block }
    (38) for -> FOR ( initialization ; . boolean ; unary ) { block }
    (45) boolean -> . boolean OR boolterm
    (46) boolean -> . boolterm
    (47) boolterm -> . boolterm AND boolterm1
    (48) boolterm -> . boolterm1
    (49) boolterm1 -> . NOT boolterm2
    (50) boolterm1 -> . boolterm2
    (51) boolterm2 -> . condition
    (52) boolterm2 -> . expression
    (53) boolterm2 -> . FALSE
    (54) boolterm2 -> . TRUE
    (55) condition -> . expression < expression
    (56) condition -> . expression > expression
    (57) condition -> . expression GTEQL expression
    (58) condition -> . expression LTEQL expression
    (59) condition -> . expression NOTEQL expression
    (60) condition -> . expression BOOLEQL expression
    (61) expression -> . expression + term
    (62) expression -> . expression - term
    (63) expression -> . term
    (64) term -> . term * factor
    (65) term -> . term / factor
    (66) term -> . factor
    (67) factor -> . ID
    (68) factor -> . NUMBER
    (69) factor -> . ( expression )

    NOT             shift and go to state 36
    FALSE           shift and go to state 40
    TRUE            shift and go to state 41
    ID              shift and go to state 44
    NUMBER          shift and go to state 45
    (               shift and go to state 46

    boolean                        shift and go to state 111
    boolterm                       shift and go to state 34
    boolterm1                      shift and go to state 35
    boolterm2                      shift and go to state 37
    condition                      shift and go to state 38
    expression                     shift and go to state 39
    term                           shift and go to state 42
    factor                         shift and go to state 43

state 103

    (22) initialization -> VARIABLE ID . = STRING
    (23) initialization -> VARIABLE ID . = boolean

    =               shift and go to state 52


state 104

    (39) for -> FOR ID IN RANGE . ( expression , expression ) { block }

    (               shift and go to state 112


state 105

    (32) if -> IF boolean { block . } elif

    }               shift and go to state 113


state 106

    (40) print -> PRINT ( plist ) .

    VARIABLE        reduce using rule 40 (print -> PRINT ( plist ) .)
    ID              reduce using rule 40 (print -> PRINT ( plist ) .)
    WHILE           reduce using rule 40 (print -> PRINT ( plist ) .)
    FOR             reduce using rule 40 (print -> PRINT ( plist ) .)
    IF              reduce using rule 40 (print -> PRINT ( plist ) .)
    PRINT           reduce using rule 40 (print -> PRINT ( plist ) .)
    $end            reduce using rule 40 (print -> PRINT ( plist ) .)
    }               reduce using rule 40 (print -> PRINT ( plist ) .)
    RETURN          reduce using rule 40 (print -> PRINT ( plist ) .)


state 107

    (41) plist -> pstat , . plist
    (41) plist -> . pstat , plist
    (42) plist -> . pstat
    (43) pstat -> . STRING
    (44) pstat -> . boolean
    (45) boolean -> . boolean OR boolterm
    (46) boolean -> . boolterm
    (47) boolterm -> . boolterm AND boolterm1
    (48) boolterm -> . boolterm1
    (49) boolterm1 -> . NOT boolterm2
    (50) boolterm1 -> . boolterm2
    (51) boolterm2 -> . condition
    (52) boolterm2 -> . expression
    (53) boolterm2 -> . FALSE
    (54) boolterm2 -> . TRUE
    (55) condition -> . expression < expression
    (56) condition -> . expression > expression
    (57) condition -> . expression GTEQL expression
    (58) condition -> . expression LTEQL expression
    (59) condition -> . expression NOTEQL expression
    (60) condition -> . expression BOOLEQL expression
    (61) expression -> . expression + term
    (62) expression -> . expression - term
    (63) expression -> . term
    (64) term -> . term * factor
    (65) term -> . term / factor
    (66) term -> . factor
    (67) factor -> . ID
    (68) factor -> . NUMBER
    (69) factor -> . ( expression )

    STRING          shift and go to state 81
    NOT             shift and go to state 36
    FALSE           shift and go to state 40
    TRUE            shift and go to state 41
    ID              shift and go to state 44
    NUMBER          shift and go to state 45
    (               shift and go to state 46

    pstat                          shift and go to state 80
    plist                          shift and go to state 114
    boolean                        shift and go to state 82
    boolterm                       shift and go to state 34
    boolterm1                      shift and go to state 35
    boolterm2                      shift and go to state 37
    condition                      shift and go to state 38
    expression                     shift and go to state 39
    term                           shift and go to state 42
    factor                         shift and go to state 43

state 108

    (4) function -> FUNCTION ID ( argument ) . { block RETURN boolean }
    (5) function -> FUNCTION ID ( argument ) . { block RETURN }

    {               shift and go to state 115


state 109

    (6) argument -> ID , argument .

    )               reduce using rule 6 (argument -> ID , argument .)


state 110

    (36) while -> WHILE boolean { block } .

    VARIABLE        reduce using rule 36 (while -> WHILE boolean { block } .)
    ID              reduce using rule 36 (while -> WHILE boolean { block } .)
    WHILE           reduce using rule 36 (while -> WHILE boolean { block } .)
    FOR             reduce using rule 36 (while -> WHILE boolean { block } .)
    IF              reduce using rule 36 (while -> WHILE boolean { block } .)
    PRINT           reduce using rule 36 (while -> WHILE boolean { block } .)
    $end            reduce using rule 36 (while -> WHILE boolean { block } .)
    }               reduce using rule 36 (while -> WHILE boolean { block } .)
    RETURN          reduce using rule 36 (while -> WHILE boolean { block } .)


state 111

    (37) for -> FOR ( initialization ; boolean . ; assign ) { block }
    (38) for -> FOR ( initialization ; boolean . ; unary ) { block }
    (45) boolean -> boolean . OR boolterm

    ;               shift and go to state 116
    OR              shift and go to state 61


state 112

    (39) for -> FOR ID IN RANGE ( . expression , expression ) { block }
    (61) expression -> . expression + term
    (62) expression -> . expression - term
    (63) expression -> . term
    (64) term -> . term * factor
    (65) term -> . term / factor
    (66) term -> . factor
    (67) factor -> . ID
    (68) factor -> . NUMBER
    (69) factor -> . ( expression )

    ID              shift and go to state 44
    NUMBER          shift and go to state 45
    (               shift and go to state 46

    expression                     shift and go to state 117
    term                           shift and go to state 42
    factor                         shift and go to state 43

state 113

    (32) if -> IF boolean { block } . elif
    (33) elif -> . ELSEIF boolean { block } elif
    (34) elif -> . ELSE { block }
    (35) elif -> . empty
    (9) empty -> .

    ELSEIF          shift and go to state 119
    ELSE            shift and go to state 120
    VARIABLE        reduce using rule 9 (empty -> .)
    ID              reduce using rule 9 (empty -> .)
    WHILE           reduce using rule 9 (empty -> .)
    FOR             reduce using rule 9 (empty -> .)
    IF              reduce using rule 9 (empty -> .)
    PRINT           reduce using rule 9 (empty -> .)
    $end            reduce using rule 9 (empty -> .)
    }               reduce using rule 9 (empty -> .)
    RETURN          reduce using rule 9 (empty -> .)

    elif                           shift and go to state 118
    empty                          shift and go to state 121

state 114

    (41) plist -> pstat , plist .

    )               reduce using rule 41 (plist -> pstat , plist .)


state 115

    (4) function -> FUNCTION ID ( argument ) { . block RETURN boolean }
    (5) function -> FUNCTION ID ( argument ) { . block RETURN }
    (10) block -> . statement block
    (11) block -> . statement
    (12) statement -> . declaration
    (13) statement -> . initialization
    (14) statement -> . assign
    (15) statement -> . funcall
    (16) statement -> . unary
    (17) statement -> . while
    (18) statement -> . for
    (19) statement -> . if
    (20) statement -> . print
    (21) declaration -> . VARIABLE ID
    (22) initialization -> . VARIABLE ID = STRING
    (23) initialization -> . VARIABLE ID = boolean
    (24) assign -> . ID = STRING
    (25) assign -> . ID = boolean
    (26) assign -> . ID = funcall
    (31) funcall -> . ID ( argument )
    (27) unary -> . increment
    (28) unary -> . decrement
    (36) while -> . WHILE boolean { block }
    (37) for -> . FOR ( initialization ; boolean ; assign ) { block }
    (38) for -> . FOR ( initialization ; boolean ; unary ) { block }
    (39) for -> . FOR ID IN RANGE ( expression , expression ) { block }
    (32) if -> . IF boolean { block } elif
    (40) print -> . PRINT ( plist )
    (29) increment -> . ID INCRMNT
    (30) decrement -> . ID DECRMNT

    VARIABLE        shift and go to state 17
    ID              shift and go to state 18
    WHILE           shift and go to state 21
    FOR             shift and go to state 22
    IF              shift and go to state 23
    PRINT           shift and go to state 24

    block                          shift and go to state 122
    statement                      shift and go to state 7
    declaration                    shift and go to state 8
    initialization                 shift and go to state 9
    assign                         shift and go to state 10
    funcall                        shift and go to state 11
    unary                          shift and go to state 12
    while                          shift and go to state 13
    for                            shift and go to state 14
    if                             shift and go to state 15
    print                          shift and go to state 16
    increment                      shift and go to state 19
    decrement                      shift and go to state 20

state 116

    (37) for -> FOR ( initialization ; boolean ; . assign ) { block }
    (38) for -> FOR ( initialization ; boolean ; . unary ) { block }
    (24) assign -> . ID = STRING
    (25) assign -> . ID = boolean
    (26) assign -> . ID = funcall
    (27) unary -> . increment
    (28) unary -> . decrement
    (29) increment -> . ID INCRMNT
    (30) decrement -> . ID DECRMNT

    ID              shift and go to state 125

    assign                         shift and go to state 123
    unary                          shift and go to state 124
    increment                      shift and go to state 19
    decrement                      shift and go to state 20

state 117

    (39) for -> FOR ID IN RANGE ( expression . , expression ) { block }
    (61) expression -> expression . + term
    (62) expression -> expression . - term

    ,               shift and go to state 126
    +               shift and go to state 70
    -               shift and go to state 71


state 118

    (32) if -> IF boolean { block } elif .

    VARIABLE        reduce using rule 32 (if -> IF boolean { block } elif .)
    ID              reduce using rule 32 (if -> IF boolean { block } elif .)
    WHILE           reduce using rule 32 (if -> IF boolean { block } elif .)
    FOR             reduce using rule 32 (if -> IF boolean { block } elif .)
    IF              reduce using rule 32 (if -> IF boolean { block } elif .)
    PRINT           reduce using rule 32 (if -> IF boolean { block } elif .)
    $end            reduce using rule 32 (if -> IF boolean { block } elif .)
    }               reduce using rule 32 (if -> IF boolean { block } elif .)
    RETURN          reduce using rule 32 (if -> IF boolean { block } elif .)


state 119

    (33) elif -> ELSEIF . boolean { block } elif
    (45) boolean -> . boolean OR boolterm
    (46) boolean -> . boolterm
    (47) boolterm -> . boolterm AND boolterm1
    (48) boolterm -> . boolterm1
    (49) boolterm1 -> . NOT boolterm2
    (50) boolterm1 -> . boolterm2
    (51) boolterm2 -> . condition
    (52) boolterm2 -> . expression
    (53) boolterm2 -> . FALSE
    (54) boolterm2 -> . TRUE
    (55) condition -> . expression < expression
    (56) condition -> . expression > expression
    (57) condition -> . expression GTEQL expression
    (58) condition -> . expression LTEQL expression
    (59) condition -> . expression NOTEQL expression
    (60) condition -> . expression BOOLEQL expression
    (61) expression -> . expression + term
    (62) expression -> . expression - term
    (63) expression -> . term
    (64) term -> . term * factor
    (65) term -> . term / factor
    (66) term -> . factor
    (67) factor -> . ID
    (68) factor -> . NUMBER
    (69) factor -> . ( expression )

    NOT             shift and go to state 36
    FALSE           shift and go to state 40
    TRUE            shift and go to state 41
    ID              shift and go to state 44
    NUMBER          shift and go to state 45
    (               shift and go to state 46

    boolean                        shift and go to state 127
    boolterm                       shift and go to state 34
    boolterm1                      shift and go to state 35
    boolterm2                      shift and go to state 37
    condition                      shift and go to state 38
    expression                     shift and go to state 39
    term                           shift and go to state 42
    factor                         shift and go to state 43

state 120

    (34) elif -> ELSE . { block }

    {               shift and go to state 128


state 121

    (35) elif -> empty .

    VARIABLE        reduce using rule 35 (elif -> empty .)
    ID              reduce using rule 35 (elif -> empty .)
    WHILE           reduce using rule 35 (elif -> empty .)
    FOR             reduce using rule 35 (elif -> empty .)
    IF              reduce using rule 35 (elif -> empty .)
    PRINT           reduce using rule 35 (elif -> empty .)
    $end            reduce using rule 35 (elif -> empty .)
    }               reduce using rule 35 (elif -> empty .)
    RETURN          reduce using rule 35 (elif -> empty .)


state 122

    (4) function -> FUNCTION ID ( argument ) { block . RETURN boolean }
    (5) function -> FUNCTION ID ( argument ) { block . RETURN }

    RETURN          shift and go to state 129


state 123

    (37) for -> FOR ( initialization ; boolean ; assign . ) { block }

    )               shift and go to state 130


state 124

    (38) for -> FOR ( initialization ; boolean ; unary . ) { block }

    )               shift and go to state 131


state 125

    (24) assign -> ID . = STRING
    (25) assign -> ID . = boolean
    (26) assign -> ID . = funcall
    (29) increment -> ID . INCRMNT
    (30) decrement -> ID . DECRMNT

    =               shift and go to state 29
    INCRMNT         shift and go to state 31
    DECRMNT         shift and go to state 32


state 126

    (39) for -> FOR ID IN RANGE ( expression , . expression ) { block }
    (61) expression -> . expression + term
    (62) expression -> . expression - term
    (63) expression -> . term
    (64) term -> . term * factor
    (65) term -> . term / factor
    (66) term -> . factor
    (67) factor -> . ID
    (68) factor -> . NUMBER
    (69) factor -> . ( expression )

    ID              shift and go to state 44
    NUMBER          shift and go to state 45
    (               shift and go to state 46

    expression                     shift and go to state 132
    term                           shift and go to state 42
    factor                         shift and go to state 43

state 127

    (33) elif -> ELSEIF boolean . { block } elif
    (45) boolean -> boolean . OR boolterm

    {               shift and go to state 133
    OR              shift and go to state 61


state 128

    (34) elif -> ELSE { . block }
    (10) block -> . statement block
    (11) block -> . statement
    (12) statement -> . declaration
    (13) statement -> . initialization
    (14) statement -> . assign
    (15) statement -> . funcall
    (16) statement -> . unary
    (17) statement -> . while
    (18) statement -> . for
    (19) statement -> . if
    (20) statement -> . print
    (21) declaration -> . VARIABLE ID
    (22) initialization -> . VARIABLE ID = STRING
    (23) initialization -> . VARIABLE ID = boolean
    (24) assign -> . ID = STRING
    (25) assign -> . ID = boolean
    (26) assign -> . ID = funcall
    (31) funcall -> . ID ( argument )
    (27) unary -> . increment
    (28) unary -> . decrement
    (36) while -> . WHILE boolean { block }
    (37) for -> . FOR ( initialization ; boolean ; assign ) { block }
    (38) for -> . FOR ( initialization ; boolean ; unary ) { block }
    (39) for -> . FOR ID IN RANGE ( expression , expression ) { block }
    (32) if -> . IF boolean { block } elif
    (40) print -> . PRINT ( plist )
    (29) increment -> . ID INCRMNT
    (30) decrement -> . ID DECRMNT

    VARIABLE        shift and go to state 17
    ID              shift and go to state 18
    WHILE           shift and go to state 21
    FOR             shift and go to state 22
    IF              shift and go to state 23
    PRINT           shift and go to state 24

    block                          shift and go to state 134
    statement                      shift and go to state 7
    declaration                    shift and go to state 8
    initialization                 shift and go to state 9
    assign                         shift and go to state 10
    funcall                        shift and go to state 11
    unary                          shift and go to state 12
    while                          shift and go to state 13
    for                            shift and go to state 14
    if                             shift and go to state 15
    print                          shift and go to state 16
    increment                      shift and go to state 19
    decrement                      shift and go to state 20

state 129

    (4) function -> FUNCTION ID ( argument ) { block RETURN . boolean }
    (5) function -> FUNCTION ID ( argument ) { block RETURN . }
    (45) boolean -> . boolean OR boolterm
    (46) boolean -> . boolterm
    (47) boolterm -> . boolterm AND boolterm1
    (48) boolterm -> . boolterm1
    (49) boolterm1 -> . NOT boolterm2
    (50) boolterm1 -> . boolterm2
    (51) boolterm2 -> . condition
    (52) boolterm2 -> . expression
    (53) boolterm2 -> . FALSE
    (54) boolterm2 -> . TRUE
    (55) condition -> . expression < expression
    (56) condition -> . expression > expression
    (57) condition -> . expression GTEQL expression
    (58) condition -> . expression LTEQL expression
    (59) condition -> . expression NOTEQL expression
    (60) condition -> . expression BOOLEQL expression
    (61) expression -> . expression + term
    (62) expression -> . expression - term
    (63) expression -> . term
    (64) term -> . term * factor
    (65) term -> . term / factor
    (66) term -> . factor
    (67) factor -> . ID
    (68) factor -> . NUMBER
    (69) factor -> . ( expression )

    }               shift and go to state 136
    NOT             shift and go to state 36
    FALSE           shift and go to state 40
    TRUE            shift and go to state 41
    ID              shift and go to state 44
    NUMBER          shift and go to state 45
    (               shift and go to state 46

    boolean                        shift and go to state 135
    boolterm                       shift and go to state 34
    boolterm1                      shift and go to state 35
    boolterm2                      shift and go to state 37
    condition                      shift and go to state 38
    expression                     shift and go to state 39
    term                           shift and go to state 42
    factor                         shift and go to state 43

state 130

    (37) for -> FOR ( initialization ; boolean ; assign ) . { block }

    {               shift and go to state 137


state 131

    (38) for -> FOR ( initialization ; boolean ; unary ) . { block }

    {               shift and go to state 138


state 132

    (39) for -> FOR ID IN RANGE ( expression , expression . ) { block }
    (61) expression -> expression . + term
    (62) expression -> expression . - term

    )               shift and go to state 139
    +               shift and go to state 70
    -               shift and go to state 71


state 133

    (33) elif -> ELSEIF boolean { . block } elif
    (10) block -> . statement block
    (11) block -> . statement
    (12) statement -> . declaration
    (13) statement -> . initialization
    (14) statement -> . assign
    (15) statement -> . funcall
    (16) statement -> . unary
    (17) statement -> . while
    (18) statement -> . for
    (19) statement -> . if
    (20) statement -> . print
    (21) declaration -> . VARIABLE ID
    (22) initialization -> . VARIABLE ID = STRING
    (23) initialization -> . VARIABLE ID = boolean
    (24) assign -> . ID = STRING
    (25) assign -> . ID = boolean
    (26) assign -> . ID = funcall
    (31) funcall -> . ID ( argument )
    (27) unary -> . increment
    (28) unary -> . decrement
    (36) while -> . WHILE boolean { block }
    (37) for -> . FOR ( initialization ; boolean ; assign ) { block }
    (38) for -> . FOR ( initialization ; boolean ; unary ) { block }
    (39) for -> . FOR ID IN RANGE ( expression , expression ) { block }
    (32) if -> . IF boolean { block } elif
    (40) print -> . PRINT ( plist )
    (29) increment -> . ID INCRMNT
    (30) decrement -> . ID DECRMNT

    VARIABLE        shift and go to state 17
    ID              shift and go to state 18
    WHILE           shift and go to state 21
    FOR             shift and go to state 22
    IF              shift and go to state 23
    PRINT           shift and go to state 24

    block                          shift and go to state 140
    statement                      shift and go to state 7
    declaration                    shift and go to state 8
    initialization                 shift and go to state 9
    assign                         shift and go to state 10
    funcall                        shift and go to state 11
    unary                          shift and go to state 12
    while                          shift and go to state 13
    for                            shift and go to state 14
    if                             shift and go to state 15
    print                          shift and go to state 16
    increment                      shift and go to state 19
    decrement                      shift and go to state 20

state 134

    (34) elif -> ELSE { block . }

    }               shift and go to state 141


state 135

    (4) function -> FUNCTION ID ( argument ) { block RETURN boolean . }
    (45) boolean -> boolean . OR boolterm

    }               shift and go to state 142
    OR              shift and go to state 61


state 136

    (5) function -> FUNCTION ID ( argument ) { block RETURN } .

    FUNCTION        reduce using rule 5 (function -> FUNCTION ID ( argument ) { block RETURN } .)
    VARIABLE        reduce using rule 5 (function -> FUNCTION ID ( argument ) { block RETURN } .)
    ID              reduce using rule 5 (function -> FUNCTION ID ( argument ) { block RETURN } .)
    WHILE           reduce using rule 5 (function -> FUNCTION ID ( argument ) { block RETURN } .)
    FOR             reduce using rule 5 (function -> FUNCTION ID ( argument ) { block RETURN } .)
    IF              reduce using rule 5 (function -> FUNCTION ID ( argument ) { block RETURN } .)
    PRINT           reduce using rule 5 (function -> FUNCTION ID ( argument ) { block RETURN } .)


state 137

    (37) for -> FOR ( initialization ; boolean ; assign ) { . block }
    (10) block -> . statement block
    (11) block -> . statement
    (12) statement -> . declaration
    (13) statement -> . initialization
    (14) statement -> . assign
    (15) statement -> . funcall
    (16) statement -> . unary
    (17) statement -> . while
    (18) statement -> . for
    (19) statement -> . if
    (20) statement -> . print
    (21) declaration -> . VARIABLE ID
    (22) initialization -> . VARIABLE ID = STRING
    (23) initialization -> . VARIABLE ID = boolean
    (24) assign -> . ID = STRING
    (25) assign -> . ID = boolean
    (26) assign -> . ID = funcall
    (31) funcall -> . ID ( argument )
    (27) unary -> . increment
    (28) unary -> . decrement
    (36) while -> . WHILE boolean { block }
    (37) for -> . FOR ( initialization ; boolean ; assign ) { block }
    (38) for -> . FOR ( initialization ; boolean ; unary ) { block }
    (39) for -> . FOR ID IN RANGE ( expression , expression ) { block }
    (32) if -> . IF boolean { block } elif
    (40) print -> . PRINT ( plist )
    (29) increment -> . ID INCRMNT
    (30) decrement -> . ID DECRMNT

    VARIABLE        shift and go to state 17
    ID              shift and go to state 18
    WHILE           shift and go to state 21
    FOR             shift and go to state 22
    IF              shift and go to state 23
    PRINT           shift and go to state 24

    initialization                 shift and go to state 9
    assign                         shift and go to state 10
    block                          shift and go to state 143
    statement                      shift and go to state 7
    declaration                    shift and go to state 8
    funcall                        shift and go to state 11
    unary                          shift and go to state 12
    while                          shift and go to state 13
    for                            shift and go to state 14
    if                             shift and go to state 15
    print                          shift and go to state 16
    increment                      shift and go to state 19
    decrement                      shift and go to state 20

state 138

    (38) for -> FOR ( initialization ; boolean ; unary ) { . block }
    (10) block -> . statement block
    (11) block -> . statement
    (12) statement -> . declaration
    (13) statement -> . initialization
    (14) statement -> . assign
    (15) statement -> . funcall
    (16) statement -> . unary
    (17) statement -> . while
    (18) statement -> . for
    (19) statement -> . if
    (20) statement -> . print
    (21) declaration -> . VARIABLE ID
    (22) initialization -> . VARIABLE ID = STRING
    (23) initialization -> . VARIABLE ID = boolean
    (24) assign -> . ID = STRING
    (25) assign -> . ID = boolean
    (26) assign -> . ID = funcall
    (31) funcall -> . ID ( argument )
    (27) unary -> . increment
    (28) unary -> . decrement
    (36) while -> . WHILE boolean { block }
    (37) for -> . FOR ( initialization ; boolean ; assign ) { block }
    (38) for -> . FOR ( initialization ; boolean ; unary ) { block }
    (39) for -> . FOR ID IN RANGE ( expression , expression ) { block }
    (32) if -> . IF boolean { block } elif
    (40) print -> . PRINT ( plist )
    (29) increment -> . ID INCRMNT
    (30) decrement -> . ID DECRMNT

    VARIABLE        shift and go to state 17
    ID              shift and go to state 18
    WHILE           shift and go to state 21
    FOR             shift and go to state 22
    IF              shift and go to state 23
    PRINT           shift and go to state 24

    initialization                 shift and go to state 9
    unary                          shift and go to state 12
    block                          shift and go to state 144
    statement                      shift and go to state 7
    declaration                    shift and go to state 8
    assign                         shift and go to state 10
    funcall                        shift and go to state 11
    while                          shift and go to state 13
    for                            shift and go to state 14
    if                             shift and go to state 15
    print                          shift and go to state 16
    increment                      shift and go to state 19
    decrement                      shift and go to state 20

state 139

    (39) for -> FOR ID IN RANGE ( expression , expression ) . { block }

    {               shift and go to state 145


state 140

    (33) elif -> ELSEIF boolean { block . } elif

    }               shift and go to state 146


state 141

    (34) elif -> ELSE { block } .

    VARIABLE        reduce using rule 34 (elif -> ELSE { block } .)
    ID              reduce using rule 34 (elif -> ELSE { block } .)
    WHILE           reduce using rule 34 (elif -> ELSE { block } .)
    FOR             reduce using rule 34 (elif -> ELSE { block } .)
    IF              reduce using rule 34 (elif -> ELSE { block } .)
    PRINT           reduce using rule 34 (elif -> ELSE { block } .)
    $end            reduce using rule 34 (elif -> ELSE { block } .)
    }               reduce using rule 34 (elif -> ELSE { block } .)
    RETURN          reduce using rule 34 (elif -> ELSE { block } .)


state 142

    (4) function -> FUNCTION ID ( argument ) { block RETURN boolean } .

    FUNCTION        reduce using rule 4 (function -> FUNCTION ID ( argument ) { block RETURN boolean } .)
    VARIABLE        reduce using rule 4 (function -> FUNCTION ID ( argument ) { block RETURN boolean } .)
    ID              reduce using rule 4 (function -> FUNCTION ID ( argument ) { block RETURN boolean } .)
    WHILE           reduce using rule 4 (function -> FUNCTION ID ( argument ) { block RETURN boolean } .)
    FOR             reduce using rule 4 (function -> FUNCTION ID ( argument ) { block RETURN boolean } .)
    IF              reduce using rule 4 (function -> FUNCTION ID ( argument ) { block RETURN boolean } .)
    PRINT           reduce using rule 4 (function -> FUNCTION ID ( argument ) { block RETURN boolean } .)


state 143

    (37) for -> FOR ( initialization ; boolean ; assign ) { block . }

    }               shift and go to state 147


state 144

    (38) for -> FOR ( initialization ; boolean ; unary ) { block . }

    }               shift and go to state 148


state 145

    (39) for -> FOR ID IN RANGE ( expression , expression ) { . block }
    (10) block -> . statement block
    (11) block -> . statement
    (12) statement -> . declaration
    (13) statement -> . initialization
    (14) statement -> . assign
    (15) statement -> . funcall
    (16) statement -> . unary
    (17) statement -> . while
    (18) statement -> . for
    (19) statement -> . if
    (20) statement -> . print
    (21) declaration -> . VARIABLE ID
    (22) initialization -> . VARIABLE ID = STRING
    (23) initialization -> . VARIABLE ID = boolean
    (24) assign -> . ID = STRING
    (25) assign -> . ID = boolean
    (26) assign -> . ID = funcall
    (31) funcall -> . ID ( argument )
    (27) unary -> . increment
    (28) unary -> . decrement
    (36) while -> . WHILE boolean { block }
    (37) for -> . FOR ( initialization ; boolean ; assign ) { block }
    (38) for -> . FOR ( initialization ; boolean ; unary ) { block }
    (39) for -> . FOR ID IN RANGE ( expression , expression ) { block }
    (32) if -> . IF boolean { block } elif
    (40) print -> . PRINT ( plist )
    (29) increment -> . ID INCRMNT
    (30) decrement -> . ID DECRMNT

    VARIABLE        shift and go to state 17
    ID              shift and go to state 18
    WHILE           shift and go to state 21
    FOR             shift and go to state 22
    IF              shift and go to state 23
    PRINT           shift and go to state 24

    block                          shift and go to state 149
    statement                      shift and go to state 7
    declaration                    shift and go to state 8
    initialization                 shift and go to state 9
    assign                         shift and go to state 10
    funcall                        shift and go to state 11
    unary                          shift and go to state 12
    while                          shift and go to state 13
    for                            shift and go to state 14
    if                             shift and go to state 15
    print                          shift and go to state 16
    increment                      shift and go to state 19
    decrement                      shift and go to state 20

state 146

    (33) elif -> ELSEIF boolean { block } . elif
    (33) elif -> . ELSEIF boolean { block } elif
    (34) elif -> . ELSE { block }
    (35) elif -> . empty
    (9) empty -> .

    ELSEIF          shift and go to state 119
    ELSE            shift and go to state 120
    VARIABLE        reduce using rule 9 (empty -> .)
    ID              reduce using rule 9 (empty -> .)
    WHILE           reduce using rule 9 (empty -> .)
    FOR             reduce using rule 9 (empty -> .)
    IF              reduce using rule 9 (empty -> .)
    PRINT           reduce using rule 9 (empty -> .)
    $end            reduce using rule 9 (empty -> .)
    }               reduce using rule 9 (empty -> .)
    RETURN          reduce using rule 9 (empty -> .)

    elif                           shift and go to state 150
    empty                          shift and go to state 121

state 147

    (37) for -> FOR ( initialization ; boolean ; assign ) { block } .

    VARIABLE        reduce using rule 37 (for -> FOR ( initialization ; boolean ; assign ) { block } .)
    ID              reduce using rule 37 (for -> FOR ( initialization ; boolean ; assign ) { block } .)
    WHILE           reduce using rule 37 (for -> FOR ( initialization ; boolean ; assign ) { block } .)
    FOR             reduce using rule 37 (for -> FOR ( initialization ; boolean ; assign ) { block } .)
    IF              reduce using rule 37 (for -> FOR ( initialization ; boolean ; assign ) { block } .)
    PRINT           reduce using rule 37 (for -> FOR ( initialization ; boolean ; assign ) { block } .)
    $end            reduce using rule 37 (for -> FOR ( initialization ; boolean ; assign ) { block } .)
    }               reduce using rule 37 (for -> FOR ( initialization ; boolean ; assign ) { block } .)
    RETURN          reduce using rule 37 (for -> FOR ( initialization ; boolean ; assign ) { block } .)


state 148

    (38) for -> FOR ( initialization ; boolean ; unary ) { block } .

    VARIABLE        reduce using rule 38 (for -> FOR ( initialization ; boolean ; unary ) { block } .)
    ID              reduce using rule 38 (for -> FOR ( initialization ; boolean ; unary ) { block } .)
    WHILE           reduce using rule 38 (for -> FOR ( initialization ; boolean ; unary ) { block } .)
    FOR             reduce using rule 38 (for -> FOR ( initialization ; boolean ; unary ) { block } .)
    IF              reduce using rule 38 (for -> FOR ( initialization ; boolean ; unary ) { block } .)
    PRINT           reduce using rule 38 (for -> FOR ( initialization ; boolean ; unary ) { block } .)
    $end            reduce using rule 38 (for -> FOR ( initialization ; boolean ; unary ) { block } .)
    }               reduce using rule 38 (for -> FOR ( initialization ; boolean ; unary ) { block } .)
    RETURN          reduce using rule 38 (for -> FOR ( initialization ; boolean ; unary ) { block } .)


state 149

    (39) for -> FOR ID IN RANGE ( expression , expression ) { block . }

    }               shift and go to state 151


state 150

    (33) elif -> ELSEIF boolean { block } elif .

    VARIABLE        reduce using rule 33 (elif -> ELSEIF boolean { block } elif .)
    ID              reduce using rule 33 (elif -> ELSEIF boolean { block } elif .)
    WHILE           reduce using rule 33 (elif -> ELSEIF boolean { block } elif .)
    FOR             reduce using rule 33 (elif -> ELSEIF boolean { block } elif .)
    IF              reduce using rule 33 (elif -> ELSEIF boolean { block } elif .)
    PRINT           reduce using rule 33 (elif -> ELSEIF boolean { block } elif .)
    $end            reduce using rule 33 (elif -> ELSEIF boolean { block } elif .)
    }               reduce using rule 33 (elif -> ELSEIF boolean { block } elif .)
    RETURN          reduce using rule 33 (elif -> ELSEIF boolean { block } elif .)


state 151

    (39) for -> FOR ID IN RANGE ( expression , expression ) { block } .

    VARIABLE        reduce using rule 39 (for -> FOR ID IN RANGE ( expression , expression ) { block } .)
    ID              reduce using rule 39 (for -> FOR ID IN RANGE ( expression , expression ) { block } .)
    WHILE           reduce using rule 39 (for -> FOR ID IN RANGE ( expression , expression ) { block } .)
    FOR             reduce using rule 39 (for -> FOR ID IN RANGE ( expression , expression ) { block } .)
    IF              reduce using rule 39 (for -> FOR ID IN RANGE ( expression , expression ) { block } .)
    PRINT           reduce using rule 39 (for -> FOR ID IN RANGE ( expression , expression ) { block } .)
    $end            reduce using rule 39 (for -> FOR ID IN RANGE ( expression , expression ) { block } .)
    }               reduce using rule 39 (for -> FOR ID IN RANGE ( expression , expression ) { block } .)
    RETURN          reduce using rule 39 (for -> FOR ID IN RANGE ( expression , expression ) { block } .)

